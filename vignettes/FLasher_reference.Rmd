---
title: "FLasher reference manual"
author: Finlay Scott, Iago Mosqueira - European Commission Joint Research Center
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: article
header-includes: 
  - \usepackage{float}
  - \usepackage{microtype}
  - \usepackage[T1]{fontenc}
  - \usepackage[bitstream-charter]{mathdesign}
output:
  pdf_document:
    toc: true
    fig_caption: yes
    number_sections: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{FLasher}
tags: [FLR FLasher forecast fisheries]
abstract:
license: European Union Public Licence (EUPL) V.1.1
---

```{r, pkgs, echo=FALSE, message=FALSE}
library(Rcpp)
library(FLasher)
library(ggplotFL)
library(knitr)
opts_chunk$set(dev='png', cache=FALSE, fig.width=5, fig.height=4.5, tidy=TRUE, dpi=300)
options(width=60)
```


# Introduction

This document focuses on the details of the projection methods of the *FLasher* package. These are implemented in C++ using *RCpp* amd *CppAD*.
Particular attention is paid to the `operatingModel` class, and how the components of an `operatingModel` object (`FLFisheries`, `fwdBiols` etc.) interact.

Details on how the basic C++ classes are implemented and used can be found in the *FLCpp* vignette.

# Example objects

We need some simple objects to demonstrate the functionality.

MOVE DOWN TO WHERE FIRST USED

```{r, demoobjects}

# A simple operating model
#om3 <- make_test_operatingModel3(niters = 100, sd = 0.1)
data(ple4)
```

# The `operatingModel` class

In *FLasher*, an operating model is made up of the fisheries (that perform fishing activity) and the biological stocks.
Operating models are represented by the `operatingModel` class.

ADD DIAGRAM

## The biological stocks

Each biological stock is represented by an object of class `fwdBiol` (analagous to the `FLBiol` class in R). This contains the abundance and life history information of the biological stock through time.
The stock recruitment relationship is also contained here, as an object of class `fwdSR`.

DIAGRAM?

## The fisheries

The fisheries are represented by an object of class `FLFisheries`. This is a list of `FLFishery` objects, each of which represents an individual fishery.
An `FLFishery` is a fleet (set of vessels) that has the same metier or gear type, e.g. beam trawlers or long lines.
A fishery is made up of a series of catches, each one is represented by an object of class `FLCatch`.
Each `FLCatch` object represents the catch from a fish stock (usually from a single biological stock - mixing catches from more than one stock is a special case where multiple biological stocks are represented as catches from a single stock).
It is possible for a fishery to have only a single catch, i.e. it only catches from one biological stock.
Multiple catches inside a fishery cannot catch from the same biological stock, i.e. a fishery can only catch once from a biological stock.

The `FLCatch` object contains the landing and discard numbers and weights along with the selectivity and catchability parameters.
They interact with the biological stocks by imposing fishing mortality.
Fishing effort is defined at the level of the fishery so that all catches inside the same fishery have the same effort.

For example if a fishery catches plaice and sole, there would be two `FLCatch` objects: one for plaice and one for sole. Each one would have different landing and discards weights, selectivity and catchability. However, they have the effort as fishing effort is defined at the fishery level not the catch level.


<!--
Costs are at vessel level (fixed costs) but what about vessels that use multiple gears.  During a year each gear does not use the same effort. But effort is defined at the fishery level.  So we consider each gear as a seperate fishery? But then your costs are split between two fishery objects for same vessel.
-->

DIAGRAM

## Examples of operating models

The simplest operating model is one which has a single fishery with a single catch fishing a single biological stock.

A mixed fishery is one with technical interactions (i.e. a stock may be caught by more than fishery or type of gear).
Simple example: two fisheries on one stock.

# The projection process

Each timestep of a projection is handled independently.
The projection is driven by the effort in the `FLFisheries` at that timestep (i.e. the effort in each 'FLFishery' in the operating model).

The projection is split into two stages: projecting the fisheries (to calculate the current catches based on the effort and biological abundance in the current time step) and projecting the biology (to calculate the biological abundance in the next timestep).

In both of these steps fishing mortality is the key metric that drives removals resulting in the catches and changes in the biological stock abundance.

# Calculating the fishing mortality

Fishing effort drives the catches and biological stock abundance through fishing mortality.
As such, it is a key metric of the model.

Fishing mortality (F) is an age-structured metric that represents the impact of fishing on the stock.
Inside *FLasher* it is the result of the interaction between an `FLCatch` and an `fwdBiol` object.

As mentioned above, a `fwdBiol` can be fished by multiple `FLCatch`es.
INSERT DIAGRAM OF MULTIPLE CATCHES ON A STOCK

The fishing mortality imposed on a `fwdBiol` from a single `FLCatch` is known as the partial fishing mortality.
The partial fishing mortality is calculated as:

$pF_{a,c,b} = \alpha_{c} Sel_{a,c} E_{f}$

where $a$ is age, $b$ the `fwdBiol`, $c$ the `FLCatch`, $f$ is the `FLFishery` that contains the `FLCatch`, $pF$ is the partial fishing mortality, $\alpha$ is the catchability scaling parameter, $Sel$ is the gear selectivity and $E$ is the fishing effort.
$\alpha$ can be set so that a particular effort and selectivity result in the desired F.
Note that fishing effort is set at the `FLFishery` level and each `FLCatch` of an `FLFishery` has the same fishing effort.

THIS CHANGE NEEDS TO BE AFFECTED IN THE CODE

The total fishing mortality imposed on a stock from all the `FLCatches` that fish it is the sum of the partial fishing mortalities:

$F_{a,b} = pF_{a,b,c1} + pF_{a,b,c2} + ...$

where $cx$ is the index of the `FLCatch`es fishing the stock, $F$ is the total fishing mortality and $pF$ is the partial fishing mortality.

<!-- OLD
$F_{a,c,b} = \alpha_{c} B_{b}^{-\beta_{c}} S_{a,c} E_{c}$
where $a$ is age, $c$ the `FLCatch`, $b$ the `fwdBiol`, $F$ is the fishing mortality, $\alpha$ and $\beta$ are the catchability parameters, $B$ is the total biomass, $S$ is the gear selectivity and $E$ is the fishing effort. Note that fishing effort is set at the `FLFishery` level and each `FLCatch` of an `FLFishery` has the same fishing effort.
-->

<!--
NOTE: THIS RELATIONSHIP IS ABOUT TO CHANGE AND INCLUDE AN ADDITIONAL $\gamma$ term.
-->

Internally, the catchability parameter, $\alpha$, is stored in the `FLCatch` object as an `FLQuant`. This means that it can vary over the year, unit, season, area and iter dimension (the first dimension is not used). For example, $\alpha$ could increase over time to represent technological creep.
The value of $\alpha$ is recycled over the dimensions over which it does not change i.e. if $\alpha$ does not change over any dimension then it is only necessary to set a single value in the `FLQuant`(see example in section \ref{sec:recycle_q}).

The selectivity is also stored in the `FLCatch` object as an age-structured `FLQuant`.  This means that it can vary over the year, unit, season, area and iter dimension. The selectivity should be scaled between 0 and 1.
The selectivity `FLQuant` needs to be the correct dimensions for the whole projection, i.e. there is no recycling apart from the iter dimension.

Effort is stored at the `FLFishery` level so that the same effort is used for all the `FLCatch` objects in the fishery.
It is stored as an `FLQuant` but the first dimension is not used.
The effort`FLQuant` needs to be the correct dimensions for the whole projection, i.e. there is no recycling apart from the iter dimension.

# Projecting the fisheries

In each time step of the projection, the landings and discards numbers are updated in the `FLCatch`es of the `FLFishery` objects.
The projection is carried out using the `project_fisheries()` method.
Catch numbers at age in each time step are calculated for each of the `FLCatch` objects inside each of the `FLFishery` using the Baranov equation (REF).

A biological stock may be fished by more than one `FLCatch`.
The catch of one `FLCatch` from a biological stock is known as the partial catch.
The total catch of a biological stock equals the sum of the partial catches from that stock.

$C_{a,b} = pC_{a,b,c1} + pC_{a,b,c2} + ...$

where $cx$ the `FLCatch`, $C$ is the total catch and $pC$ is the partial catch from each `FLCatch`. 
Where a stock is only fished by a single `FLCatch`, the partial catch is equal to the total catch.

The partial catch of a `FLCatch` from a biological stock is given as:

$pC_{a,b,c} = (pF_{a,b,c} / Z_{a,b}) * (1 - exp(-Z_{a,b})) * N_{a,b}$

where $a$ is age, $b$ the `fwdBiol`, $c$ the `FLCatch`, $pC$ is the partial catch, $pF$ is the partial fishing mortality, $Z$ is the total mortality of the biological stock being fished (total fishing mortality of the stock plus natural mortality) and $N$ is abundance of the biological stock being fished.

The total mortality is given as:

$Z_{a,b} = F_{a,b} + m_{a,b}$

where $m$ is the natural mortality of the biological stock.

$N$ and $m$ are stored in the corresponding `fwdBiol` object.

Landings and discards numbers are calculated by splitting the catch numbers using the discard ratio.
When the `FLFishery` is created in C++ from the R objects, the discard ratio is calculated from the existing landings and discards numbers in the R-based object, i.e. the future discard ratio can be set up by entering the appropriate values in the future landings and discards numbers. These values are then written over with the actual landings and discards during the projection.

$DR_{a,c} = D_{a,c} / / (D_{a,c} + L_{a,c})$

where $DR$ is the discard rate, $D$ is the discard numbers and $L$ is the landings numbers.

In C++, the discard ratio is stored as an `FLQuant` of the `FLCatch` object.
During a projection it is used to split the calculated catch numbers into landings and discards:

$L_{a,c} = pC_{a,c} * (1 - DR_{a,c})$
$D_{a,c} = pC_{a,c} * DR_{a,c}$

There is a special case where a single `FLCatch` may catch from more than one stock (for example, where two biological stocks are considered to be a single stock by the management regime).
In this special case the sum of the landings and discard numbers from each stock are in the `FLCatch`.

## Differences with FLash concerning catch weights at age

There is a difference between *FLasher* and *FLash* concerning the calculation of total catch biomass.
In *FLasher* and *FLash* catch numbers at age are the sum of the landing and discards numbers at age.
In *FLash* the mean catch weights at age are fixed in advance in using the `catch.wt` slot.
In *FLasher* the mean catch weights at age are calculated using the landings and discards numbers and weights at age.
This means the that mean catch weights at age in *FLasher* are not fixed in advance but will change according to the projected landings and discards numbers.
The result is that the mean catch weights at age will differ between *FLash* and *FLasher*.
This difference is most noticeable when a total catch is set as a target. Both *FLash* and *FLasher* will hit the same total catch weight target but because the mean catch weights at age are different, the catch numbers at age will be different.


# Projecting the biology

The biological stocks are projected one timestep at a time by the `project_biols()` method.
The method calculates the survivors from the previous timestep and places them in the current timestep.
Recruitment in the current timestep is also calculated.

The stocks are processed one at a time (the order in which they appear in the `biols` member).
The stocks are independent of each other and there is no interaction between them.

The basic process is:

- Calculate total mortality ($Z$) on the stock in the previous timestep (see above).
- Calculate survivors ($S$) for the current timestep.
- Calculate recruitment for the current timestep.
- Place survivors and recruitment in the appropriate age classes in the current timestep.

## Calculating survivors
 
The abundances in a `fwdBiol` class represent the abundance at the start of a timestep.
The survivors at the end of a timestep, $S$, from age, $a$, at the end of a timestep (given by year, $y$ and season, $s$) are calculated as:

$S_{a,y,s} = N_{a,y,s} exp(-Z_{a,y,s})$

where $N$ is the population abundance.

The survivors are put into the abundances in the next timestep.
The age group that survivors are placed in depends on the timestep and the timing of recruitment.
The recruitment is always added to the first age group of the stock in the timestep in which it occurred.
As the projection progresses, the survivors at the end of a timestep are placed in the same age group in the next timestep until they are a year older.
When they are a year older, the survivors are placed in the next age group.

For example, say we have a projection with 4 seasons to a year and the stock only recruits once a year in season 3.
Recruits enter the first age group in season 3.
In year 1, season 4, the survivors from season 3 are placed in the same age group (e.g. the recruits from season 3 are moved to the first age group in season 4, less those that died).
The same thing happens for year 2 in seasons 1 and 2. 
In year 2, season 3 (the recruitment season) the survivors are placed in the next age group, i.e. the individuals are now a year older.

EXAMPLE?

# Recruitment

Recruitment is one of the most important processes in the dynamics of the biology as it drives the productivity.
It is also a source of great uncertainty and can be strongly affected by external drivers such as environmental conditions.

In *Flasher*, calculating recruitment has two main stages:

1. Calculating the Stock Recruitment Potential (SRP)
2. Calculating the recruitment from the SRP: $R = f(SRP)$

A stock may spawn and recruit more than one time in a year.
When a stock recruits more than one time in year, the resulting recruitment each event is placed into a new unit of the stock.
The recruitment of each unit of a `fwdBiol` is calculated separately and may have different stock recruitment parameters.
However, the SRP that results in the recruitment is the total SRP across all units, i.e. the SRP of each individual unit is not considered only the total.

## SRP

The SRP represents the total spawning potential of the stock at the time of spawning.

As mentioned above, a biological stock may have multiple units (from multiple recruitment events in a year). 
Although the SRP of each unit can be calculated individually, the SRP that is used to calculate recruitment is the total SRP of all units.
The total SRP of a `fwdBiol` in a timestep is given by the sum of the SRPs of each unit.

$SRP_{y,s} = \sum_{u=1}^{U}SRP_{y,s,u}$

where $u$ is the unit where $U$ the total number of units.

There are several possible ways of calculating SRP, e.g. spawning stock biomass (SSB), egg production etc.
At the moment *Flasher* only uses SSB but it may be possible to include others in the future.

The SSB of a unit in a timestep is given by:

$SSB_{y,s,u} = \sum_{a=1}^{A} N_{a,y,s,u} Mat_{a,y,s,u} Wt_{a,y,s,u} exp(-Zprespwn_{a,y,s,u})$

Where $A$ is the number of ages in the stock, $Mat$ is the proportion mature (the `mat` slot of an *FLBiol*), $Wt$ is the mean weights at age (the `wt` slot of an *FLBiol*) and $Zprespwn$ is the amount of mortality (fishing and natural) experienced by the stock before spawning occurs in that timestep (see next section).


## The timing of spawning

As SRP is the spawning potential of the stock _at the time of spawning_, timing is very important in the calculation of the SRP.

In R, the timing of spawning is handled by the `spwn` slot of the *FLBiol* (in C++ it is the `spwn` member of the *fwdBiol*).
`spwn` is an *FLQuant* with a length of one in the first dimension (i.e. no age structure). It takes a value of 0 - 1 which describes the point in the timestep when spawning happens.
For example, a value of 0 means that spawning happens at the start of the timestep, a value of 0.5 is halfway through the timestep, a value of 1 is the end of the timestep and so on.
Importantly, a value of NA means that there is no spawning in that timestep and the calculated SRP of that unit in that timestep is 0.0 (not NA).

When a stock has multiple units, it is possible for different units to spawn at different times. However, this is pretty unusual.
Generally, all units spawn at the same time but care must be taken to place the resulting recruitment in the correct unit (see below).

When calculating SRP in a timestep it is necessary to calculate the abundance at the time of spawning. 
Although, with a seasonal model, spawning will probably happen at the start of a timestep, with an annual model this may not be the case. EXAMPLE.
If spawning happens part way through a timestep, by the time the population spawns it will have experienced natural mortality and possibly fishing mortality.
This means that the abundance at the time of spawning will be lower than at the start of the timestep.
In *FLasher* the abundances in a timestep are the abundances at the start of that timestep.
Consequently, we need to calculate the population abundance at the time of spawning, not at the start of the timestep.
For example, if spawning occurs midway through the year for an annual model, we need to calculate the abundance midway through the year, after some of the natural and fishing mortality have taken place.

In the calculation of SRP the decrease in abundance at the time of spawning is handled by $Zprespwn$. This is the sum of the amount of fishing and natural mortality experienced by the stock before spawning, $Fprespwn$ and $Mprespwn$ respectively:

$Zprespwn = Fprespwn + Mprespwn$

$Fprespwn$ needs to consider the timing of spawning and the timing of the fishing period within each timestep.
The timing of fishing is controlled by the `hperiod` slot of an *FLFishery* (so that each *FLCatch* of a fishery has the same timing).
`hperiod` is an *FLQuant* with length two in the first dimension. It is not age structured and the first dimension has names `start` and `end` to hold the start and end times of the fishing period in that timestep. The values are between 0 and 1 in the same way as the `spwn` slot of the *FLBiol*.
A value of NA in `start` means no fishing in that timestep (alternatively, the effort can be set to 0).

A stock can be fished by more than one fishery.
$Fprespwn$ is calculated for each fishery that fishes the stock and then summed.
For each fishery that fishes on the stock, it is necessary to calculate how much fishing has occured before spawning in a timestep. If fishing starts after spawning ($start > spwn$) then the population abundance at spawning time is unaffected by fishing from that fishery.
If fishing finishes before spawning ($end < spwn$) then the population abundance at spawning is reduced by the total fishing mortality from that fishery in that timestep.
If `spwn` falls in between `start` and `end` then it is necessary to calulate how much fishing has occured before spawning.
This calculation is handled by the `f_prop_spwn()` method (a member of the *operatingModel* class).
This calculates the proportion of the fishing mortality from each fishery that happens before spawning, $Fpropmult$.
The fishing mortality from a fishery that is applied before spawning is then the total fishing mortality from that fishery multiplied by the proportion:

$Fprespwn = F * Fpropmult$

Natural mortality is assumed to happen continuously throughout the year so the amount of natural mortality before spawning is:

$Mprespwn = M * spwn$

## Example SRP calculation

In this example, we make an operating model with 1 fishery and 1 catch that fishes on a single stock.
There are 4 seasons. The stock spawns twice a year, in seasons 2 (unit 2) and 4 (unit 1).
When spawning occurs, both units spawn at the same time.
The `spwn` slot of the biol reflects this, with `spwn` in both units set to NA in the seasons that it does not spawn and set to 0 in the seasons that it does (meaning that the stock spawns at the beginning of the timestep).

```{r, srp_example}
# Make the simple OM with 1 fishery, 1 biol and 4 seasons
FCB <- array(c(1,1,1), dim=c(1,3), dimnames=list(1,c("F","C","B")))
# Recruitment in seasons 1 and 3, so spawning in seasons 4 and 2
om <- make_test_operatingModel(ple4, FCB, nseasons = 4, recruitment_seasons = c(1,3), recruitment_age = 1, niters = 20, sd = 0.1)
# Take a look at the spwn slot
# We have two units. They both spawn in seasons 2 and 4.
spwn(om[["biols"]][[1]][["biol"]])[,1:5,1,]
spwn(om[["biols"]][[1]][["biol"]])[,1:5,2,]
# Get the SRP for five years
srp <- test_operatingModel_SRP_FLQ_subset(om[["fisheries"]], om[["biols"]], om[["fwc"]], 1, c(1,1,1,1,1), c(5,2,4,1,20))
# SRP of unit 1 has SRP in season 2 and 4 
srp[,,1]
# SRP of unit 2 also has SRP in season 2 and 4 
srp[,,2]
# Total SRP of biol - also in season 2 and 4
total_srp <- test_operatingModel_total_SRP_FLQ_subset(om[["fisheries"]], om[["biols"]], om[["fwc"]], 1, c(1,1,1,1,1), c(5,2,4,1,20))
total_srp
```

## Timing of SRP and recruitment

Spawning is assumed to result in recruitment at age 0. However, the first age of the model is not necessarily 0.
Therefore, When calculating recruitment it is necessary to use the SRP in the appropriate timestep.
For example, if the first age of the stock is 1, then the current recruitment is a function of the SRP one year ago.
The method `srp_timelag()' (a member of the `fwdBiol` class) calculates the lag between the current timestep and the timestep of the corresponding SRP.
The returned timelag depends on the first age of the stock and whether the model is seasonal:

- If the first age is 0 and the model has a seasonal timestep, the timelag is 1 season i.e. the SRP comes from the previous season.
- If the first age is 0 and the model has an annual timestep, the timelag is 0, i.e. there is no timelag and the SRP is calculated in the current timestep (it's a strange case).
- If the first age is >= 1, the timelag is the product of the first age and the number of seasons in the model, i.e. the number of timesteps between the first age and age 0 in the same season. Note that if the model is annual, there is 1 effectively season.

For example, if the model is annual and the first age is 2, recruitment is a function of the SRP 2 years ago, which is 2 timesteps.
If the model has 4 seasons and the first age is 2, recruitment is a function of the SRP 2 years ago, which is 8 timesteps.

### Examples of timing of SRP and recruitment

Here we show a few examples of calculating the timelag between SRP and recruitment.

```{r, srp_timelag}
# Annual model with first age 0
# timelag of 0 (SRP and recruitment in same year)
biol1 <- random_FLBiolcpp_generator(fixed_dims = c(5,5,1,1,1,1), min_age_name = 0)
test_fwdBiol_srp_timelag(biol1)
# Annual model with first age 2
# timelag of 2 (SRP from 2 years ago)
biol1 <- random_FLBiolcpp_generator(fixed_dims = c(5,5,1,1,1,1), min_age_name = 2)
test_fwdBiol_srp_timelag(biol1)
# Seasonal model (12 seasons) with first age 0
# timelag of 1 - SRP comes from previous timestep
biol1 <- random_FLBiolcpp_generator(fixed_dims = c(5,5,1,12,1,1), min_age_name = 0)
test_fwdBiol_srp_timelag(biol1)
# Seasonal model (12 seasons) with first age 2
# timelag of 24 - SRP comes from same season, but 2 years ago 
biol1 <- random_FLBiolcpp_generator(fixed_dims = c(5,5,1,12,1,1), min_age_name = 2)
test_fwdBiol_srp_timelag(biol1)
```

## SRR parameters

SOMETHING ON RECYCLING OF PARAMETERS AND HOW THEY ARE CALLED

## Recruitment

Timing of SRP and SRR params

THESE EQUATIONS IGNORE TIMING


$R_{y,s,u} = f(SRP_{y,s})$



<!--
### Multiple recruitment events

NOT YET IMPLEMENTED

Within a year a stock may recruit multiple times.
To ensure that the growth of an individual is consistent with its recruitment season, it is necessary to account for the individuals from each recruitment seperately. 

For example, consider a stock that recruits in seasons 1 and 3. The recruits from each event will be placed in the first age group. However, the individuals that were recruited in season 1 will be two seasons older than those that are recruited in season 3. Consequently, their mean mass and other metrics will be different.
We have to keep track of the individuals recruited in season 1 and season 3 separately.
To do this we use the *unit* dimension.

The *unit* dimension is used to store information on individuals from different recruitment events.
The individuals that results from each recruitment event in a year must be stored in a different unit.
Each unit can only recruit once per year.

SRP IS FROM ACROSS ALL UNITS
-->


# Examples

## Recycling catchability parameter $\alpha$
\label{sec:recycle_q}

In this example we show how the catchability is recycled in the FLasher C++ code.
An example `FLCatch` object is made with a single value of $\alpha$.
Internally, this single value is recycled over all dimensions as necessary.

```{r, recycle_alpha}
# Get an FLCatch from the simple operating model
catch1 <- om3$fisheries[["fishery"]][["catch"]]
# Look at the catchability parameters
catch.q(catch1)
dim(catch.q(catch1))
# Call the C++ method to access years 1 to 4 and iters 1 to 5 of alpha
recycled_q <- test_FLCatchAD_catch_q_params_subset(catch1, c(1,1,1,1,1,1), c(1,4,1,1,1,5))
is(recycled_q)
dim(recycled_q)
# Note that dimnames have not been set - that is OK as it is used internally
recycled_q
```


<!--
## Recruitment

A stock may recruit in any timestep.
Recruitment is calculated in every timestep. If there is no recruitment in that timestep the calculated recruitment is 0.
The calculated recruitment is placed into the first age group of the `fwdBiol`.

Recruitment is a function of the spawning reproductive potential (SRP) of the stock and a stock-recruitment function.
The stock recruitment function and the parameters are stored in an object of class of`fwdSR`. Each `fwdBiol` has a `fwdSR`.

### Stock recruitment parameters

Internally, the stock recruitment parameters are stored as an `FLQuant` along the first dimension. 
This means that the SRR parameters can be disaggregated by the *year*, *unit*, *season*, *area* and *iter* dimensions.
In this way trends and uncertainty etc. can be added to the parameters.

If the parameters are not disaggregated then they are recycled where necessary. For example, if we are running a multi year projection but the SRR parameters are not disaggregated by year, the same values are used for each year.

EXAMPLE 

Because of this recycling, we need to be careful to set the stock recruitment parameters to NA for the timesteps and units in which recruitment does not occur.
For example, if we are running a model with 4 seasons in which the stock only recruits once per year, in season 2, we need to ensure that the parameters have seasons and that in seasons 1, 3 and 4 the values are set to NA.




### Timing of recruitment

The timing of recruitment is important. For example, in determining the correct age group in which to place survivors.
The timing is determined by the stock recruitment parameters. If the value of the first parameter in a particular timestep is NA then recruitment does not happen in that timestep and the calculated recruitment value is 0.

`does_recruitment_happen()`





The main method is `calc_rec()` which takes the `fwdBiol` number and the `timestep`.
AT THE MOMENT ALSO TAKES UNIT NUMBER, i.e. RECRUITMENT FOR EACH UNIT IS CALCED SEPARATELY - NEED TO FIX THIS

### SRP


Given that the age structure of the stock may not start at age 0, it necessary to calculate the SRP at the appropriate time that lead to the current recruitment.
For example, if the first age of the stock is 1, then the current recruitment is a function of the SRP one year ago.
The method `srp_timelag()' (a member of the `fwdBiol` class) calculates the lag between the current timestep and the timestep of the appropriate SRP.
The returned SRP timelag depends on the first age of the stock and whether the model is seasonal:

- If the first age is 0 and the model has a seasonal timestep, the timelag is 1 season i.e. the SRP comes from the previous season.
- If the first age is 0 and the model has an annual timestep, the timelag is 0, i.e. there is no timelag and the SRP is calculated in the current timestep (it's a strange case).
- If the first age is >1, the timelag is the product of the first age and the number of seasons in the model, i.e. the difference between the first age and age 0 in the same season (the time of spawning). Note that if the model is annual, there is 1 season.

SPAWNING IS ASSUMED TO BE AN INSTANTANEOUS EVENT THAT HAPPENS AT A POINT DURING THE TIMESTEP

The SRP at the appropriate timestep is calculated using the `srp()` method, a member of the `operatingModel` class.

The SRP calculation is built around 3 parameters that are members of the `fwdBiol` class (and the `FLBiolCpp` class in R):

- `spwn` - the proportion of the time through the timestep when spawning occurs (0 the start, 1 the end, NA no spawning happens). e.g. if `spwn` = 0.5 then spawning happens halfway through the timestep.
- `fec` - the fecundity of the stock - MEANING WHAT
- `mat` - the proportion mature in each age group.

CHECK THE 'SPWN = NA' thing, RESULTING SSB CURRENTLY NA BUT SHOULD BE 0.0.
BUT WHAT IS RESULTING RECRUITMENT

SRP can be calculated in many different ways. For example, total egg production (TEP) and spawning stock biomass (SSB)
At the moment, only SSB is available.

###### SSB calculation

The SSB in a timestep is calculated as:

$SSB =  \sum_{a=age1}^{max~age} N_{a} Wt_{a} Mat_{a} exp(-Z_{prespawn,a})$

where $a$ is the age, $N$ is the abundance, $Wt$ the average individual mass, $Mat$ the proportion mature and $Z_{prespawn}$ is the total mortality that occurs before spawning in that timestep.
$Z$ is the sum of $F$ and natural mortality, $M$ i.e.:

$Z_{prespawn, a} = F_{prespawn, a}$ and $M_{prespawn, a}$

where $F_{prespawn}$ and $M_{prespawn}$ are the fishing mortality and natural mortality that occur before spawning in that timestep respectively.
$M_{prespawn, a}$ is relatively simple to calculate:

$M_{prespawn, a} = Spwn * M_{a}$

where $Spwn$ is `spwn` as described above.

$F_{prespawn, a}$ is more complicated as it needs to take it into account when fishing occurs during the timestep:

$F_{prespawn, a} = F_{a} F_{prop~prespawn}$

where $F_{prop~prespawn}$ is the proportion of fishing that occurs before spawning and is dependent on the time of spawning, $Spwn$, and the timing of fishing.
The timing of fishing is given by two parameters $F_{start}$ and $F_{end}$ which give the proportion through the timestep.
This information is stored at the `FLFishery` level in the member `hperiod`. The timing of fishing activity is not structured by age (*quant*) or *unit*, but can change over time (*year* and *season*), *area* and *iter*.

WHAT HAPPENS IF THESE ARE NA? DOES IT MEAN NO FISHING? SAME AS EFFORT = 0? OR AN ERROR? PropF should = 0, i.e. it should not affect SSB calc.


$F_{prop~prespawn}$ is calculated by the `f_prop_spwn()` method, a member of the `operatingModel` class. It evaluates three possibilities:

- If $F_{end} < Spwn$ then $F_{prop~prespawn} = 1.0$,  i.e. all fishing takes place before spawning.
- If $F_{start} > Spwn$ then $F_{prop~prespawn} = 0.0$, i.e. all fishing takes place after spawning.
- Else $F_{prop~prespawn} = (Spwn - F_{start}) / (F_{end} - F_{start})$, i.e. spawning happens at some point during the fishing period. 

When the stock is fished by multiple ``FLCatch``es, the $F$ parts from each ``FLCatch`` are summed.

HOW ARE UNITS DEALT WITH?

#### Recruitment prediction

Following the calculation of the SRP, the `predict_recruitment()` method is called, taking the SRP and the recruitment timestep.
This method calculates the recruitment based on the SRP and the SRR parameters at the recruitment timestep,
It then applies the residuals to the calculated recruitment.


Internally, the residuals are the same size as the rest of the operating model apart from along the first dimension (which is always 1 - there is no age structure to the residuals) and the *iter* dimension which must be 1 or the same as the *iter* dimension in the operating model. The residuals are recycled along the *iter* dimension if necessary.
For example, if the number of iterations in the operating model is 1000 and there is only iteration in the residuals, the residuals are recycled over the operating model iterations.

<!--
### Examples
#
#We can use the built in `make_test_operatingModel3()` function to create the elements needed for a simple operating model with one fishery fishing on a single stock (all based on the `ple4` data set).
#
#```{r makeOM3}
#niters <- 10
#om <- make_test_operatingModel3(niters=niters)
#```
#
### SSB calculation

<!--

At the moment the `srp()` method calculates the SSB.
Here we define a function in C++ that exposes this method to R and compile using `cppFunction()` from *Rcpp*.

```{r makeSRPtestfunc}
#source <- '
#FLQuantAD ssb_cpp(FLFisheriesAD flfs, fwdBiolsAD biols, const fwdControl ctrl, const std::vector<unsigned int> indices_min, const std::vector<unsigned int> indices_max){
#    operatingModel om(flfs, biols, ctrl);
#    return om.srp(1, indices_min, indices_max);
#}
#'
#cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
```

We calculate the SSB with differing values in the `spwn` and `hperiod` slots to demonstrate the impact of the timing of fishing and the timing of spawning.

For demonstration purposes, we only calculate the SSB for the first year and iteration.

In this first example, all the fishing occurs after spawning has occured. We set the `spwn` slot to 0 (so spawning occurs at the beginning of the timestep) and the `hperiod` to 1.0 (a pulse fishery at the end of the timestep).

```{r spwn_before_fish}
#spwn(om$biols[[1]][[1]])[] <- 0.0
#hperiod(om$fisheries[[1]])["start",] <- 1.0
#hperiod(om$fisheries[[1]])["end",] <- 1.0
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```

If spawning happens after the fishing has occured, we get a lower SSB (the stock will also have experienced a whole timesteps worth of natural mortality too):
```{r spwn_after_fish}
#spwn(om$biols[[1]][[1]])[] <- 1.0
#hperiod(om$fisheries[[1]])["start",] <- 0.0
#hperiod(om$fisheries[[1]])["end",] <- 0.0
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```

If spawning happens during the fishing period, the result is somewhere in between:
```{r spwn_during_fish}
#spwn(om$biols[[1]][[1]])[] <- 0.5 
#hperiod(om$fisheries[[1]])["start",] <- 0.3
#hperiod(om$fisheries[[1]])["end",] <- 0.6
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```
If no spawning happens in that timestep we set the `spwn` slot to NA.
This results in a SSB of NA:
SHOULD BE 0?

```{r NAspwn}
#spwn(om$biols[[1]][[1]])[] <- NA
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```
-->

<!--
### Calculating recruitment

Here we demonstrate how the recruitment is calculated.
We again use the simple operating model with a single catch and fishery.
The operating model has iterations but as we set the `sd`argument to 0, each iteration is the same.

```{r makeOM3_again}
#niters <- 10
#om <- make_test_operatingModel3(niters=niters, sd = 0.0)
```

FIX THIS WHEN SPWN = NA

To keep things simple, we set spawning to occur at the start of the timestep, before the fishing period.

```{r spwn_before_fish_again}
#spwn(om$biols[[1]][[1]])[] <- 0.0 
## spwn(om$biols[[1]][[1]])[] <- NA 
#hperiod(om$fisheries[[1]])["start",] <- 1.0 
#hperiod(om$fisheries[[1]])["end",] <- 1.0
```

We write a function that exposes the C++ ``calc_rec()`` method to R:

```{r makeRectestfunc}
#source <- '
#std::vector<double> rec_cpp(FLFisheriesAD flfs, fwdBiolsAD biols, const fwdControl ctrl, unsigned int timestep){
#    operatingModel om(flfs, biols, ctrl);
#    std::vector<adouble> rec_ad = om.calc_rec(1, 1, timestep);
#    std::vector<double> rec(rec_ad.size());
#    std::transform(rec_ad.begin(), rec_ad.end(), rec.begin(), [](adouble x) {return Value(x);});
#    return rec;
#}
#'
#cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
```

In the default example the SRR parameters do not have a time structure, the values are recycled and the same value is used for all years and seasons.
Similarly, here there are also no iterations and the values are recycled over all iterations.

```{r srr_params}
#om$biols[[1]]$srr_params
```

We calculate the recruitment in year 10. We have iterations but as the iterations are all the same, there is no variability in the calculated recruitment:

```{r rec1}
#year <- 10
#rec_cpp(om$fisheries, om$biols, om$fwc, 10)
```

We can add iterations to the SRR paramers. Here we just add some random noise. This results in random noise in the predicted recruitment:

```{r srr_params_iters}
#srp <- propagate(om$biols[[1]]$srr_params, niters)
#srp <- srp * rlnorm(srp, mean=0, sd = 0.1)
#om$biols[[1]]$srr_params <- srp
#rec_cpp(om$fisheries, om$biols, om$fwc, 10)
```

The SRR parameters can vary by any of the dimensions in a FLQuant (apart from the first one, which is used to store the different parameters), e.g. by year and season to model a trend.

SOMETHING ON RESIDUALS AND RECYCLING TOO

-->


# Recruitment in different seasons

HOW ARE DIFFERENT RECRUITMENT EVENTS HANDLED

# Projection targets

WHAT HAPPENS WITH SRP AS A TARGET - TIMELAGS


# References

