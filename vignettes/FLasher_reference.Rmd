---
title: "FLasher reference manual"
author: Finlay Scott, Iago Mosqueira - European Commission Joint Research Center
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: article
header-includes: 
  - \usepackage{float}
  - \usepackage{microtype}
  - \usepackage[T1]{fontenc}
  - \usepackage[bitstream-charter]{mathdesign}
output:
  pdf_document:
    toc: true
    fig_caption: yes
    number_sections: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{FLasher}
tags: [FLR FLasher forecast fisheries]
abstract:
license: European Union Public Licence (EUPL) V.1.1
---

```{r, pkgs, echo=FALSE, message=FALSE}
library(Rcpp)
library(FLasher)
library(ggplotFL)
library(knitr)
opts_chunk$set(dev='png', cache=FALSE, fig.width=5, fig.height=4.5, tidy=TRUE, dpi=300)
options(width=60)
```


# Introduction

This document focuses on the details of the projection methods of the *FLasher* package. These are implemented in C++ using *RCpp* amd *CppAD*.
Particular attention is paid to the `operatingModel` class, and how the components of an `operatingModel` object (`FLFisheries`, `fwdBiols` etc.) interact.

Details on how the basic C++ classes are implemented and used can be found in the *FLCpp* vignette.

# Example objects

We need some simple objects to demonstrate the functionality.

MOVE DOWN TO WHERE FIRST USED

```{r, demoobjects}

# A simple operating model
om3 <- make_test_operatingModel3(niters = 100, sd = 0.1)
```

# The `operatingModel` class

In *FLasher*, an operating model is made up of the fisheries (that perform fishing activity) and the biological stocks.
Operating models are represented by the `operatingModel` class.

ADD DIAGRAM

## The biological stocks

Each biological stock is represented by an object of class `fwdBiol` (analagous to the `FLBiol` class in R). This contains the abundance and life history information of the biological stock through time.
The stock recruitment relationship is also contained here, as an object of class `fwdSR`.

DIAGRAM?

## The fisheries

The fisheries are represented by an object of class `FLFisheries`. This is a list of `FLFishery` objects, each of which represents an individual fishery.
An `FLFishery` is a fleet (set of vessels) that has the same metier or gear type, e.g. beam trawlers or long lines.
A fishery is made up of a series of catches, each one is represented by an object of class `FLCatch`.
Each `FLCatch` object represents the catch from a fish stock (usually from a single biological stock - mixing catches from more than one stock is a special case where multiple biological stocks are represented as catches from a single stock).
It is possible for a fishery to have only a single catch, i.e. it only catches from one biological stock.
Multiple catches inside a fishery cannot catch from the same biological stock, i.e. a fishery can only catch once from a biological stock.

The `FLCatch` object contains the landing and discard numbers and weights along with the selectivity and catchability parameters.
They interact with the biological stocks by imposing fishing mortality.
Fishing effort is defined at the level of the fishery so that all catches inside the same fishery have the same effort.

For example if a fishery catches plaice and sole, there would be two `FLCatch` objects: one for plaice and one for sole. Each one would have different landing and discards weights, selectivity and catchability. However, they have the effort as fishing effort is defined at the fishery level not the catch level.


<!--
Costs are at vessel level (fixed costs) but what about vessels that use multiple gears.  During a year each gear does not use the same effort. But effort is defined at the fishery level.  So we consider each gear as a seperate fishery? But then your costs are split between two fishery objects for same vessel.
-->

DIAGRAM

## Examples of operating models

The simplest operating model is one which has a single fishery with a single catch fishing a single biological stock.

A mixed fishery is one with technical interactions (i.e. a stock may be caught by more than fishery or type of gear).
Simple example: two fisheries on one stock.

# The projection process

Each timestep of a projection is handled independently.
The projection is driven by the effort in the `FLFisheries` at that timestep (i.e. the effort in each 'FLFishery' in the operating model).

The projection is split into two stages: projecting the fisheries (to calculate the current catches based on the effort and biological abundance in the current time step) and projecting the biology (to calculate the biological abundance in the next timestep).

In both of these steps fishing mortality is the key metric that drives removals resulting in the catches and changes in the biological stock abundance.

# Calculating the fishing mortality

Fishing effort drives the catches and biological stock abundance through fishing mortality.
As such, it is a key metric of the model.

Fishing mortality (F) is an age-structured metric that represents the impact of fishing on the stock.
Inside *FLasher* it is the result of the interaction between an `FLCatch` and an `fwdBiol` object.

As mentioned above, a `fwdBiol` can be fished by multiple `FLCatch`es.
INSERT DIAGRAM OF MULTIPLE CATCHES ON A STOCK

The fishing mortality imposed on a `fwdBiol` from a single `FLCatch` is known as the partial fishing mortality.
The partial fishing mortality is calculated as:

$pF_{a,c,b} = \alpha_{c} Sel_{a,c} E_{f}$

where $a$ is age, $b$ the `fwdBiol`, $c$ the `FLCatch`, $f$ is the `FLFishery` that contains the `FLCatch`, $pF$ is the partial fishing mortality, $\alpha$ is the catchability scaling parameter, $Sel$ is the gear selectivity and $E$ is the fishing effort.
$\alpha$ can be set so that a particular effort and selectivity result in the desired F.
Note that fishing effort is set at the `FLFishery` level and each `FLCatch` of an `FLFishery` has the same fishing effort.

THIS CHANGE NEEDS TO BE AFFECTED IN THE CODE

The total fishing mortality imposed on a stock from all the `FLCatches` that fish it is the sum of the partial fishing mortalities:

$F_{a,b} = pF_{a,b,c1} + pF_{a,b,c2} + ...$

where $cx$ is the index of the `FLCatch`es fishing the stock, $F$ is the total fishing mortality and $pF$ is the partial fishing mortality.

<!-- OLD
$F_{a,c,b} = \alpha_{c} B_{b}^{-\beta_{c}} S_{a,c} E_{c}$
where $a$ is age, $c$ the `FLCatch`, $b$ the `fwdBiol`, $F$ is the fishing mortality, $\alpha$ and $\beta$ are the catchability parameters, $B$ is the total biomass, $S$ is the gear selectivity and $E$ is the fishing effort. Note that fishing effort is set at the `FLFishery` level and each `FLCatch` of an `FLFishery` has the same fishing effort.
-->

<!--
NOTE: THIS RELATIONSHIP IS ABOUT TO CHANGE AND INCLUDE AN ADDITIONAL $\gamma$ term.
-->

Internally, the catchability parameter, $\alpha$, is stored in the `FLCatch` object as an `FLQuant`. This means that it can vary over the year, unit, season, area and iter dimension (the first dimension is not used). For example, $\alpha$ could increase over time to represent technological creep.
The value of $\alpha$ is recycled over the dimensions over which it does not change i.e. if $\alpha$ does not change over any dimension then it is only necessary to set a single value in the `FLQuant`(see example in section \ref{sec:recycle_q}).

The selectivity is also stored in the `FLCatch` object as an age-structured `FLQuant`.  This means that it can vary over the year, unit, season, area and iter dimension. The selectivity should be scaled between 0 and 1.
The selectivity `FLQuant` needs to be the correct dimensions for the whole projection, i.e. there is no recycling apart from the iter dimension.

Effort is stored at the `FLFishery` level so that the same effort is used for all the `FLCatch` objects in the fishery.
It is stored as an `FLQuant` but the first dimension is not used.
The effort`FLQuant` needs to be the correct dimensions for the whole projection, i.e. there is no recycling apart from the iter dimension.

# Projecting the fisheries

In each time step of the projection, the landings and discards numbers are updated in the `FLCatch`es of the `FLFishery` objects.
The projection is carried out using the `project_fisheries()` method.
Catch numbers at age in each time step are calculated for each of the `FLCatch` objects inside each of the `FLFishery` using the Baranov equation (REF).

A biological stock may be fished by more than one `FLCatch`.
The catch of one `FLCatch` from a biological stock is known as the partial catch.
The total catch of a biological stock equals the sum of the partial catches from that stock.

$C_{a,b} = pC_{a,b,c1} + pC_{a,b,c2} + ...$

where $cx$ the `FLCatch`, $C$ is the total catch and $pC$ is the partial catch from each `FLCatch`. 
Where a stock is only fished by a single `FLCatch`, the partial catch is equal to the total catch.

The partial catch of a `FLCatch` from a biological stock is given as:

$pC_{a,b,c} = (pF_{a,b,c} / Z_{a,b}) * (1 - exp(-Z_{a,b})) * N_{a,b}$

where $a$ is age, $b$ the `fwdBiol`, $c$ the `FLCatch`, $pC$ is the partial catch, $pF$ is the partial fishing mortality, $Z$ is the total mortality of the biological stock being fished (total fishing mortality of the stock plus natural mortality) and $N$ is abundance of the biological stock being fished.

The total mortality is given as:

$Z_{a,b} = F_{a,b} + m_{a,b}$

where $m$ is the natural mortality of the biological stock.

$N$ and $m$ are stored in the corresponding `fwdBiol` object.

Landings and discards numbers are calculated by splitting the catch numbers using the discard ratio.
When the `FLFishery` is created in C++ from the R objects, the discard ratio is calculated from the existing landings and discards numbers in the R-based object, i.e. the future discard ratio can be set up by entering the appropriate values in the future landings and discards numbers. These values are then written over with the actual landings and discards during the projection.

$DR_{a,c} = D_{a,c} / / (D_{a,c} + L_{a,c})$

where $DR$ is the discard rate, $D$ is the discard numbers and $L$ is the landings numbers.

In C++, the discard ratio is stored as an `FLQuant` of the `FLCatch` object.
During a projection it is used to split the calculated catch numbers into landings and discards:

$L_{a,c} = pC_{a,c} * (1 - DR_{a,c})$
$D_{a,c} = pC_{a,c} * DR_{a,c}$

There is a special case where a single `FLCatch` may catch from more than one stock (for example, where two biological stocks are considered to be a single stock by the management regime).
In this special case the sum of the landings and discard numbers from each stock are in the `FLCatch`.

# Projecting the biology

The biological stocks are projected one timestep at a time by the `project_biols()` method.
The method calculates the survivors from the previous timestep and places them in the current timestep.
Recruitment in the current timestep is also calculated.

The stocks are processed one at a time (the order in which they appear in the `biols` member).
The stocks are independent of each other and there is no interaction between them.

The basic process is:

- Calculate total mortality ($Z$) on the stock in the previous timestep (see above).
- Calculate survivors ($S$) for the current timestep.
- Calculate recruitment for the current timestep.
- Place survivors and recruitment in the appropriate age classes in the current timestep.

## Calculating survivors
 
The survivors, $S$, from age, $a$, at the end of a timestep (given by year, $y$ and season, $s$) are calculated as:

$S_{a,y,s} = N_{a,y,s} exp(-Z_{a,y,s})$

where $N$ is the population abundance.

Where the survivors from the previous timestep are placed in the current timestep depends on the season and the timing of recruitment (see next section).

The recruitment is always added to the first age group of the stock in the timestep in which it occurred.
As the projection progresses, the survivors are placed in the same age group until they are a year older.
When they are a year older, the survivors are placed in the next age group.

For example, say we have a projection with 4 seasons to a year and the stock only recruits once a year in season 3.
Recruits enter the first age group in season 3.
In year 1, season 4, the survivors from season 3 are placed in the same age group (i.e. the recruits from season 3 are moved to the first age group in season 4, less those that died).
The same thing happens for year 2 in seasons 1 and 2. 
In year 2, season 3 (the recruitment season) the survivors are placed in the next age group, i.e. the individuals are now a year older.

EXAMPLE?


<!--
### Multiple recruitment events

NOT YET IMPLEMENTED

Within a year a stock may recruit multiple times.
To ensure that the growth of an individual is consistent with its recruitment season, it is necessary to account for the individuals from each recruitment seperately. 

For example, consider a stock that recruits in seasons 1 and 3. The recruits from each event will be placed in the first age group. However, the individuals that were recruited in season 1 will be two seasons older than those that are recruited in season 3. Consequently, their mean mass and other metrics will be different.
We have to keep track of the individuals recruited in season 1 and season 3 separately.
To do this we use the *unit* dimension.

The *unit* dimension is used to store information on individuals from different recruitment events.
The individuals that results from each recruitment event in a year must be stored in a different unit.
Each unit can only recruit once per year.

SRP IS FROM ACROSS ALL UNITS
-->


# Examples

## Recycling catchability parameter $\alpha$
\label{sec:recycle_q}

In this example we show how the catchability is recycled in the FLasher C++ code.
An example `FLCatch` object is made with a single value of $\alpha$.
Internally, this single value is recycled over all dimensions as necessary.

```{r, recycle_alpha}
# Get an FLCatch from the simple operating model
catch1 <- om3$fisheries[["fishery"]][["catch"]]
# Look at the catchability parameters
catch.q(catch1)
dim(catch.q(catch1))
# Call the C++ method to access years 1 to 4 and iters 1 to 5 of alpha
recycled_q <- test_FLCatchAD_catch_q_params_subset(catch1, c(1,1,1,1,1,1), c(1,4,1,1,1,5))
is(recycled_q)
dim(recycled_q)
# Note that dimnames have not been set - that is OK as it is used internally
recycled_q
```

<!--
## Recruitment

A stock may recruit in any timestep.
Recruitment is calculated in every timestep. If there is no recruitment in that timestep the calculated recruitment is 0.
The calculated recruitment is placed into the first age group of the `fwdBiol`.

Recruitment is a function of the spawning reproductive potential (SRP) of the stock and a stock-recruitment function.
The stock recruitment function and the parameters are stored in an object of class of`fwdSR`. Each `fwdBiol` has a `fwdSR`.

### Stock recruitment parameters

Internally, the stock recruitment parameters are stored as an `FLQuant` along the first dimension. 
This means that the SRR parameters can be disaggregated by the *year*, *unit*, *season*, *area* and *iter* dimensions.
In this way trends and uncertainty etc. can be added to the parameters.

If the parameters are not disaggregated then they are recycled where necessary. For example, if we are running a multi year projection but the SRR parameters are not disaggregated by year, the same values are used for each year.

EXAMPLE 

Because of this recycling, we need to be careful to set the stock recruitment parameters to NA for the timesteps and units in which recruitment does not occur.
For example, if we are running a model with 4 seasons in which the stock only recruits once per year, in season 2, we need to ensure that the parameters have seasons and that in seasons 1, 3 and 4 the values are set to NA.




### Timing of recruitment

The timing of recruitment is important. For example, in determining the correct age group in which to place survivors.
The timing is determined by the stock recruitment parameters. If the value of the first parameter in a particular timestep is NA then recruitment does not happen in that timestep and the calculated recruitment value is 0.

`does_recruitment_happen()`





The main method is `calc_rec()` which takes the `fwdBiol` number and the `timestep`.
AT THE MOMENT ALSO TAKES UNIT NUMBER, i.e. RECRUITMENT FOR EACH UNIT IS CALCED SEPARATELY - NEED TO FIX THIS

### SRP


Given that the age structure of the stock may not start at age 0, it necessary to calculate the SRP at the appropriate time that lead to the current recruitment.
For example, if the first age of the stock is 1, then the current recruitment is a function of the SRP one year ago.
The method `srp_timelag()' (a member of the `fwdBiol` class) calculates the lag between the current timestep and the timestep of the appropriate SRP.
The returned SRP timelag depends on the first age of the stock and whether the model is seasonal:

- If the first age is 0 and the model has a seasonal timestep, the timelag is 1 season i.e. the SRP comes from the previous season.
- If the first age is 0 and the model has an annual timestep, the timelag is 0, i.e. there is no timelag and the SRP is calculated in the current timestep (it's a strange case).
- If the first age is >1, the timelag is the product of the first age and the number of seasons in the model, i.e. the difference between the first age and age 0 in the same season (the time of spawning). Note that if the model is annual, there is 1 season.

SPAWNING IS ASSUMED TO BE AN INSTANTANEOUS EVENT THAT HAPPENS AT A POINT DURING THE TIMESTEP

The SRP at the appropriate timestep is calculated using the `srp()` method, a member of the `operatingModel` class.

The SRP calculation is built around 3 parameters that are members of the `fwdBiol` class (and the `FLBiolCpp` class in R):

- `spwn` - the proportion of the time through the timestep when spawning occurs (0 the start, 1 the end, NA no spawning happens). e.g. if `spwn` = 0.5 then spawning happens halfway through the timestep.
- `fec` - the fecundity of the stock - MEANING WHAT
- `mat` - the proportion mature in each age group.

CHECK THE 'SPWN = NA' thing, RESULTING SSB CURRENTLY NA BUT SHOULD BE 0.0.
BUT WHAT IS RESULTING RECRUITMENT

SRP can be calculated in many different ways. For example, total egg production (TEP) and spawning stock biomass (SSB)
At the moment, only SSB is available.

###### SSB calculation

The SSB in a timestep is calculated as:

$SSB =  \sum_{a=age1}^{max~age} N_{a} Wt_{a} Mat_{a} exp(-Z_{prespawn,a})$

where $a$ is the age, $N$ is the abundance, $Wt$ the average individual mass, $Mat$ the proportion mature and $Z_{prespawn}$ is the total mortality that occurs before spawning in that timestep.
$Z$ is the sum of $F$ and natural mortality, $M$ i.e.:

$Z_{prespawn, a} = F_{prespawn, a}$ and $M_{prespawn, a}$

where $F_{prespawn}$ and $M_{prespawn}$ are the fishing mortality and natural mortality that occur before spawning in that timestep respectively.
$M_{prespawn, a}$ is relatively simple to calculate:

$M_{prespawn, a} = Spwn * M_{a}$

where $Spwn$ is `spwn` as described above.

$F_{prespawn, a}$ is more complicated as it needs to take it into account when fishing occurs during the timestep:

$F_{prespawn, a} = F_{a} F_{prop~prespawn}$

where $F_{prop~prespawn}$ is the proportion of fishing that occurs before spawning and is dependent on the time of spawning, $Spwn$, and the timing of fishing.
The timing of fishing is given by two parameters $F_{start}$ and $F_{end}$ which give the proportion through the timestep.
This information is stored at the `FLFishery` level in the member `hperiod`. The timing of fishing activity is not structured by age (*quant*) or *unit*, but can change over time (*year* and *season*), *area* and *iter*.

WHAT HAPPENS IF THESE ARE NA? DOES IT MEAN NO FISHING? SAME AS EFFORT = 0? OR AN ERROR? PropF should = 0, i.e. it should not affect SSB calc.


$F_{prop~prespawn}$ is calculated by the `f_prop_spwn()` method, a member of the `operatingModel` class. It evaluates three possibilities:

- If $F_{end} < Spwn$ then $F_{prop~prespawn} = 1.0$,  i.e. all fishing takes place before spawning.
- If $F_{start} > Spwn$ then $F_{prop~prespawn} = 0.0$, i.e. all fishing takes place after spawning.
- Else $F_{prop~prespawn} = (Spwn - F_{start}) / (F_{end} - F_{start})$, i.e. spawning happens at some point during the fishing period. 

When the stock is fished by multiple ``FLCatch``es, the $F$ parts from each ``FLCatch`` are summed.

HOW ARE UNITS DEALT WITH?

#### Recruitment prediction

Following the calculation of the SRP, the `predict_recruitment()` method is called, taking the SRP and the recruitment timestep.
This method calculates the recruitment based on the SRP and the SRR parameters at the recruitment timestep,
It then applies the residuals to the calculated recruitment.


Internally, the residuals are the same size as the rest of the operating model apart from along the first dimension (which is always 1 - there is no age structure to the residuals) and the *iter* dimension which must be 1 or the same as the *iter* dimension in the operating model. The residuals are recycled along the *iter* dimension if necessary.
For example, if the number of iterations in the operating model is 1000 and there is only iteration in the residuals, the residuals are recycled over the operating model iterations.

<!--
### Examples
#
#We can use the built in `make_test_operatingModel3()` function to create the elements needed for a simple operating model with one fishery fishing on a single stock (all based on the `ple4` data set).
#
#```{r makeOM3}
#niters <- 10
#om <- make_test_operatingModel3(niters=niters)
#```
#
### SSB calculation

<!--

At the moment the `srp()` method calculates the SSB.
Here we define a function in C++ that exposes this method to R and compile using `cppFunction()` from *Rcpp*.

```{r makeSRPtestfunc}
#source <- '
#FLQuantAD ssb_cpp(FLFisheriesAD flfs, fwdBiolsAD biols, const fwdControl ctrl, const std::vector<unsigned int> indices_min, const std::vector<unsigned int> indices_max){
#    operatingModel om(flfs, biols, ctrl);
#    return om.srp(1, indices_min, indices_max);
#}
#'
#cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
```

We calculate the SSB with differing values in the `spwn` and `hperiod` slots to demonstrate the impact of the timing of fishing and the timing of spawning.

For demonstration purposes, we only calculate the SSB for the first year and iteration.

In this first example, all the fishing occurs after spawning has occured. We set the `spwn` slot to 0 (so spawning occurs at the beginning of the timestep) and the `hperiod` to 1.0 (a pulse fishery at the end of the timestep).

```{r spwn_before_fish}
#spwn(om$biols[[1]][[1]])[] <- 0.0
#hperiod(om$fisheries[[1]])["start",] <- 1.0
#hperiod(om$fisheries[[1]])["end",] <- 1.0
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```

If spawning happens after the fishing has occured, we get a lower SSB (the stock will also have experienced a whole timesteps worth of natural mortality too):
```{r spwn_after_fish}
#spwn(om$biols[[1]][[1]])[] <- 1.0
#hperiod(om$fisheries[[1]])["start",] <- 0.0
#hperiod(om$fisheries[[1]])["end",] <- 0.0
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```

If spawning happens during the fishing period, the result is somewhere in between:
```{r spwn_during_fish}
#spwn(om$biols[[1]][[1]])[] <- 0.5 
#hperiod(om$fisheries[[1]])["start",] <- 0.3
#hperiod(om$fisheries[[1]])["end",] <- 0.6
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```
If no spawning happens in that timestep we set the `spwn` slot to NA.
This results in a SSB of NA:
SHOULD BE 0?

```{r NAspwn}
#spwn(om$biols[[1]][[1]])[] <- NA
#ssb_cpp(om$fisheries, om$biols, om$fwc, c(1,1,1,1,1), c(1,1,1,1,1))
```
-->

<!--
### Calculating recruitment

Here we demonstrate how the recruitment is calculated.
We again use the simple operating model with a single catch and fishery.
The operating model has iterations but as we set the `sd`argument to 0, each iteration is the same.

```{r makeOM3_again}
#niters <- 10
#om <- make_test_operatingModel3(niters=niters, sd = 0.0)
```

FIX THIS WHEN SPWN = NA

To keep things simple, we set spawning to occur at the start of the timestep, before the fishing period.

```{r spwn_before_fish_again}
#spwn(om$biols[[1]][[1]])[] <- 0.0 
## spwn(om$biols[[1]][[1]])[] <- NA 
#hperiod(om$fisheries[[1]])["start",] <- 1.0 
#hperiod(om$fisheries[[1]])["end",] <- 1.0
```

We write a function that exposes the C++ ``calc_rec()`` method to R:

```{r makeRectestfunc}
#source <- '
#std::vector<double> rec_cpp(FLFisheriesAD flfs, fwdBiolsAD biols, const fwdControl ctrl, unsigned int timestep){
#    operatingModel om(flfs, biols, ctrl);
#    std::vector<adouble> rec_ad = om.calc_rec(1, 1, timestep);
#    std::vector<double> rec(rec_ad.size());
#    std::transform(rec_ad.begin(), rec_ad.end(), rec.begin(), [](adouble x) {return Value(x);});
#    return rec;
#}
#'
#cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
```

In the default example the SRR parameters do not have a time structure, the values are recycled and the same value is used for all years and seasons.
Similarly, here there are also no iterations and the values are recycled over all iterations.

```{r srr_params}
#om$biols[[1]]$srr_params
```

We calculate the recruitment in year 10. We have iterations but as the iterations are all the same, there is no variability in the calculated recruitment:

```{r rec1}
#year <- 10
#rec_cpp(om$fisheries, om$biols, om$fwc, 10)
```

We can add iterations to the SRR paramers. Here we just add some random noise. This results in random noise in the predicted recruitment:

```{r srr_params_iters}
#srp <- propagate(om$biols[[1]]$srr_params, niters)
#srp <- srp * rlnorm(srp, mean=0, sd = 0.1)
#om$biols[[1]]$srr_params <- srp
#rec_cpp(om$fisheries, om$biols, om$fwc, 10)
```

The SRR parameters can vary by any of the dimensions in a FLQuant (apart from the first one, which is used to store the different parameters), e.g. by year and season to model a trend.

SOMETHING ON RESIDUALS AND RECYCLING TOO

-->


# Recruitment in different seasons

HOW ARE DIFFERENT RECRUITMENT EVENTS HANDLED

# Projection targets

WHAT HAPPENS WITH SRP AS A TARGET - TIMELAGS


# References

