\documentclass[a4paper,english,10pt]{article}
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{FLCpp}
%\VignetteKeywords{R,FLR,Rcpp}
%\VignettePackage{FLasher}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{color} 
\usepackage{float}
\usepackage{longtable}
\usepackage[bottom]{footmisc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{authblk}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{babel}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{verbose,a4paper,tmargin=3cm,bmargin=2cm,lmargin=2cm,rmargin=3cm}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,        % color of internal links
    citecolor=red,         % color of links to bibliography
    filecolor=blue,        % color of file links
    urlcolor=blue          % color of external links
}

% Define some handy formatting
\newcommand{\initiative}[1]{{\texttt{#1}}}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\pkg}[1]{{\texttt{#1}}}
\newcommand{\class}[1]{{\textit{#1}}}
\newcommand{\R}{{\normalfont\textsf{R }}{}}
\newcommand{\args}[1]{{\texttt{#1}}}
\newcommand{\E}[1]{\text{E}\left[#1\right]}
\newcommand{\Var}[1]{\text{Var}\left[#1\right]}


%----------------------------------------------------------------------------------

\begin{document}

\title{FLCpp - Fisheries Library in C++}

\author[1]{Finlay Scott}
\author[1]{Iago Mosqueira}
\affil[1]{European Commission, Joint Research Centre, IPSC / Maritime Affairs Unit, 21027 Ispra (VA), Italy}
\affil[*]{Corresponding author \href{mailto:finlay.scott@jrc.ec.europa.eu}{finlay.scott@jrc.ec.europa.eu}}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

<<knitr_opts, echo=FALSE, message=FALSE, warning=FALSE>>=
library(knitr)
css = eclipse_theme(43)
thm = knit_theme$get(css)
knit_theme$set(thm)
opts_chunk$set(dev='png', cache=TRUE, fig.align='center', warning=FALSE, message=FALSE, dev="png", dev.args=list(type="cairo"), dpi=96, highlight=TRUE, background='#F2F2F2', fig.lp="fig:", fig.pos="H", width=60)
@

This document describes the basic FLR classes that have been implemented in C++ in the \pkg{FLasher} package.
The classes form the basis of the \class{operatingModel} class that is responsible for mult-species, multi-fleet projections.

These classes can also be easily used in the normal R environment through the use of the \code{cppFunction()} function and the specially written plug-in for \pkg{FLasher}.

To begin we need to load the libraries:

<<load_libraries, message=FALSE, warning=FALSE>>=
library(FLasher)
# Explicitly load Rcpp because we want to use cppFunction()
library(Rcpp)
# Useful library for testing stuff
library(testthat)
@

\section{\class{FLQuant}}

The \class{FLQuant} class is represented in C++ as a class, as called \class{FLQuant}.
Internally, the data member of the class is represented as \code{std::vector<T>}, i.e. it is a one dimensioal vector.
A range of different accessing methods are available to allow access to all 6 \class{FLQuant} dimensions. 

T is either a \code{double} or \code{adouble} for automatic differentiation using CppAD.
There are \code{typedef}s called \class{FLQuant} or \class{FLQuantAD} respectively. 
Making the FLQuant class work for other data types, e.g. other implementations of automatic differentiation, is possible.
The class also has members for units, dimensions and dimension names.


\subsection{A simple example}

A plugin has been written to allow \pkg{FLasher} to be used with the \pkg{Rcpp} \code{cppFunction()} function.
Additionally, dedicated \code{wrap<>} and \code{as<>} methods have been written to allow \class{FLQuant}s to be easily passed to and from C++ and R.
We will make use of this in this vignette.

Here we write a simple function that takes an \class{FLQuant}, multiplies it by a \class{double} and returns the result (more on mathematical operators on C++ \class{FLQuant} objects later).
First we write the C++ source code.

<<simple_example>>=
source = '
    FLQuant flq_test(FLQuant x, double mult){
        FLQuant y = x * mult;
        return y;
    }
'
@

We then compile the source code specifying the \pkg{FLasher} depends and that we need to use C++11.

<<compile_simple_example>>=
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

This makes the C++ function \code{flq\_test()} available to R. 
Let's test it.

<<test_simple_example>>=
data(ple4)
mult <- 2.0
flq_in <- catch.n(ple4)
flq_out <- flq_test(flq_in, mult)
# What is it
is(flq_out)
# Has the multiplication worked?`
flq_in[1:3,"2000"]
flq_out[1:3,"2000"]
# The following test only produces output if the test fails
expect_that(flq_in * mult, equals(flq_out))
@

\subsection{Lists of \class{FLQuant} objects: \class{FLQuant7}}

We now have a quick detour to introduce a new class, the \class{FLQuant7}. This is just a list of \class{FLQuant} objects.
It should really have been called \class{FLQuants} not \class{FLQuant7} - feel free to change it if you want.
We introduce it here because it becomes useful in the later examples for returning multiple \class{FLQuant} objects.

In this example we pass in two \class{FLQuant} objects, make an \class{FLQuant7} object from them and then return it.
<<flq7>>=
source = '
     FLQuant7 flq7_test(FLQuant x, FLQuant y){
         // Make the FLQuant7 by passing in one object
         FLQuant7 z(x);
         // Add another by using ()
         z(y);
         return z;
    }
'

cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<flq7_test>>=
flq1 <- catch.n(ple4)
flq2 <- stock.n(ple4)
flqs <- flq7_test(flq1, flq2)
# What is it? It's a list
is(flqs)
length(flqs)
expect_that(flq1, equals(flqs[[1]]))
expect_that(flq2, equals(flqs[[2]]))
@

You can do it the other way round by passing a list of \class{FLQuant} objects.
To access an element in the \class{FLQuant7} (either for setting or getting) you can use the \code{()} operator and the index of the \class{FLQuant}, starting at 1.

<<flq7_get_set>>=
source = '
     FLQuant flq7_get_test(FLQuant7 x){
         // Pull out the first FLQuant
         FLQuant y = x(1);
         return y;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)

source = '
     FLQuant7 flq7_set_test(FLQuant7 x, FLQuant y){
         // Insert an FLQuant in the 2nd position
         x(2) = y;
         return x;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<flq7_get_set_test>>=
flq3 <- flq7_get_test(flqs)
expect_that(flq3, equals(flqs[[1]]))
flq4 <- landings.n(ple4)
flqs2 <- flq7_set_test(flqs, flq4)
expect_that(flq4, equals(flqs2[[2]]))
@

You can have a list of \class{FLQuant} or \class{FLQuantAD} objects, but not a mix.



\subsection{Dimension accessors}

To get the dimensions of a \class{FLQuant} in C++ there are some accessor methods. 
For example, \code{get\_dim()} returns an integer vector of length 6 containing the size of each dimension.
In this example we use an \class{FLQuantAD} just to show it does the same thing.

<<flq_dim_accessor>>=
source = '
     std::vector<unsigned int> flq_dim_test(FLQuantAD x){
        return x.get_dim();
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
dim(flq_in)
flq_dim_test(flq_in)
@

The methods \code{get\_nquant()}, \code{get\_nyear()}, \code{get\_nunit()}, \code{get\_nseason()}, \code{get\_narea()}, \code{get\_niter()} return the sizes of the appropriate dimension.

<<flq_dim_accessors>>=
source = '
    std::vector<unsigned int> flq_dims_test(FLQuant x){
        // Make a vector to return
        std::vector<unsigned int> dim_out {
            x.get_nquant(),
            x.get_nyear(),
            x.get_nunit(),
            x.get_nseason(),
            x.get_narea(),
            x.get_niter()};
        return dim_out;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_flq_dim_accessors>>=
dim(flq_in)
flq_dims_test(flq_in)
@

There are also methods for pulling out the dimnames and units but these are not illustrated here.


\subsection{Accessing and subsetting data in an \class{FLQuant} in C++}
\label{sec:flquantaccess}

First, ALL accessors work on indices, i.e. positions within the dimension.
For example, if the year range of the \class{FLQuant} is 2000 to 2010, to access year 2005, the year index is 6.
Names do not work, only integers.

There are several ways of getting at the data in an \class{FLQuant} in C++.

\begin{itemize}
    \item Getting at a single value by passing a single index value; 
    \item Getting at a single value by passing 6 index values for the 6 dimensions;
    \item Getting at a single value by passing an integer vector of length 6;
    \item Subsetting the \class{FLQuant} by passing two integer vectors of length 6 that specify the minimum and maximum indices.
\end{itemize}

Of these, only the first three methods allow you to change the values in the \class{FLQuant}. 
The subset method is for getting the data only. It cannot be used for setting the data.

Note that the indices for accessing the \class{FLQuant} start at 1, even though we are in C++ world (\class{std::vector<>} etc. obviously start at 0).
<<set_accessor>>=
source = '
    FLQuant flq_set_accessor_test(FLQuant x, unsigned int single_index,
                                  std::vector<unsigned int> indices1,
                                  std::vector<unsigned int> indices2,
                                  double value){
        x(single_index) = value;
        x(indices1[0], indices1[1], indices1[2], indices1[3],
          indices1[4], indices1[5]) = value;
        x(indices2) = value;
        return x;
    }
'

cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_set_accessor>>=
single_index <- round(runif(1, min=1, max=prod(dim(flq_in))))
indices1 <- round(runif(6, min=1, max=dim(flq_in)))
indices2 <- round(runif(6, min=1, max=dim(flq_in)))
value <- 666
flq_out <- flq_set_accessor_test(flq_in, single_index, indices1, indices2, value)
# And test
# Single index
c(flq_in)[single_index]
c(flq_out)[single_index]
# Six seperate integers
flq_in[indices1[1], indices1[2], indices1[3], indices1[4], indices1[5], indices1[6]] 
flq_out[indices1[1], indices1[2], indices1[3], indices1[4], indices1[5], indices1[6]] 
# Vector of integers
flq_in[indices2[1], indices2[2], indices2[3], indices2[4], indices2[5], indices2[6]] 
flq_out[indices2[1], indices2[2], indices2[3], indices2[4], indices2[5], indices2[6]] 
@

If you try to access values that are outside of the dimension range, you get an error.

Which is nice.
<<set_accessor_range>>=
source = '
    FLQuant flq_range_accessor_test(FLQuant x, 
                                  std::vector<unsigned int> indices,
                                  double value){
        x(indices) = value;
        return x;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_set_accessor_range>>=
indices <- round(runif(6, min=1, max=dim(flq_in))) 
indices[1] <- dim(flq_in)[1] + 1
# Would be nice to see the error but it breaks the generation of the Vignette!
expect_that(flq_range_accessor_test(flq_in, indices, value), throws_error())
@

In this example we extract a subset of an \class{FLQuant}. As mentioned above, this can only be used for getting data (Note: I guess you could add a method a set method for subsets if you wanted).

<<subset_flquant>>=
source = '
    FLQuant flq_subset_test(FLQuant x, 
                                  std::vector<unsigned int> indices1,
                                  std::vector<unsigned int> indices2){
        // Subset using two integer vectors
        FLQuant y = x(indices1, indices2); 
        return y;
    }
'

cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_subset>>=
indices1 <- round(runif(6, min=1, max=ceiling(dim(flq_in)/2))) 
indices2 <- round(runif(6, min=ceiling(dim(flq_in)/2), max=dim(flq_in))) 
flq_out <- flq_subset_test(flq_in, indices1, indices2)
# Test subset is correct
subset_in <- flq_in[indices1[1]:indices2[1], indices1[2]:indices2[2],
indices1[3]:indices2[3], indices1[4]:indices2[4],
indices1[5]:indices2[5], indices1[6]:indices2[6]]
# If all this good, the test returns nothing
expect_that(subset_in, equals(flq_out))
@


\subsection{Mathematical operations}

All the common mathematical operations have been defined for \class{FLQuant} in C++,
i.e. you can multiply and add single values to whole \class{FLQuant} objects, add
two \class{FLQuant} objects together and so on.
Some examples are shown here.


<<flquant_maths>>=
source = '
    FLQuant7 flq_subtract_test(FLQuant x, FLQuant y, double value){
        // Subtracting a single value
        FLQuant7 z(x - value);
        z(value - x);
        // Adding a single value
        z(x + value);
        z(value + x);
        // Multiplying by a single value
        z(x * value);
        z(value * x);
        // Dividing by a single value
        z(x / value);
        z(value / x);
        // Operating on pairs of equal sized FLQuant objects
        z(x-y);
        z(x+y);
        z(x*y);
        z(x/y);
        // log and exp
        z(log(x));
        z(exp(y));
        return z;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_subset_flquant>>=
value <- runif(1)
flq1 <- landings.n(ple4)
flq2 <- catch.n(ple4)
flqs_out <- flq_subtract_test(flq1, flq2, value)
expect_that(flq1 - value, equals(flqs_out[[1]]))
expect_that(value - flq1, equals(flqs_out[[2]]))
expect_that(flq1 + value, equals(flqs_out[[3]]))
expect_that(value + flq1, equals(flqs_out[[4]]))
expect_that(flq1 * value, equals(flqs_out[[5]]))
expect_that(value * flq1, equals(flqs_out[[6]]))
expect_that(flq1 / value, equals(flqs_out[[7]]))
expect_that(value / flq1, equals(flqs_out[[8]]))
expect_that(flq1 - flq2, equals(flqs_out[[9]]))
expect_that(flq1 + flq2, equals(flqs_out[[10]]))
expect_that(flq1 * flq2, equals(flqs_out[[11]]))
expect_that(flq1 / flq2, equals(flqs_out[[12]]))
# When calling log and exp, units are not set correctly so we just check the data
expect_that(log(flq1@.Data), equals(flqs_out[[13]]@.Data))
expect_that(exp(flq2@.Data), equals(flqs_out[[14]]@.Data))
@

\subsection{Other useful functions}

There are several other basic operations available for \class{FLQuant} objects for summing over quant and year dimension (analogous to their R versions), taking the mean over the quant dimension, finding the maximum value along the quant dimension and scaling by the maximum value along the quant dimension.

<<flquant_other_methods>>=
source = '
    FLQuant7 flq_other(FLQuant x){
        FLQuant7 z(quant_sum(x));
        z(year_sum(x));
        z(quant_mean(x));
        z(max_quant(x));
        z(scale_by_max_quant(x));
        return z;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_flquant_other_methods>>=
flqs <- flq_other(flq1)
expect_that(quantSums(flq1), equals(flqs[[1]]))
# expect_that(yearSums(flq1), equals(flqs[[2]])) # broken - fix it
expect_that(apply(flq1, 2:6, mean), equals(flqs[[3]]))
expect_that(apply(flq1, 2:6, max), equals(flqs[[4]]))
scaled_flq1 <- sweep(flq1, 2:6, apply(flq1, 2:6, max), "/")
expect_that(scaled_flq1, equals(flqs[[5]]))
@

\subsection{Using iterators}

Iterators have been defined for the \class{FLQuant} class (which is essentially just a one dimensional array).
This means that you can do normal C++ iterator stuff with them.
For example, you can use lambda functions that were introduced in C++11.
This means it is straightforward to perform operations on each element of an \class{FLQuant} when that operation has not been defined for the whole object.
For example, here we take the square root of the sum of products of two \class{FLQuant} objects.

<<flquant_iterator>>=
source = '
    FLQuant flq_iterator(FLQuant flq1, FLQuant flq2){
        // Make an FLQuant of same size to dump output in
        FLQuant flq3(flq1);
        // lambda function
        std::transform(flq1.begin(), flq1.end(), flq2.begin(), flq3.begin(),
            [](double x, double y) { return sqrt(x*x + y*y); } );
        return flq3;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_flquant_iterator>>=
flq3 <- flq_iterator(flq1, flq2)
expect_that(flq3, equals(sqrt(flq1^2 + flq2^2)))
@

\subsection{Making new \class{FLQuant} objects in C++}

The easiest way to make a new \class{FLQuant} object in C++ is to copy or subset an existing object.
Otherwise, you can call the \class{FLQuant} constructor specifying the dimensions.
This creates an \class{FLQuant} object with the correct dimensions, filled with 0.
The dimnames and units are not set by the constructor but can be set afterwards using the \code{set\_dimnames()} and \code{set\_units()} methods.
The values of the object can also be set by using \code{set\_data()} method.
Setting the dimnames by hand can be fiddly because you have to create an \class{Rcpp::List} by hand.
In the following example we just pass them in by hand.

<<flquant_constructor>>=
source = '
    FLQuant7 flq_constructor(std::vector<unsigned int> dim, double value, std::string units, Rcpp::List dimnames, std::vector<double> data){
        FLQuant7 out;
        // Make an empty one filled with 0s and add it to the list
        FLQuant flq(dim[0], dim[1], dim[2], dim[3], dim[4], dim[5]);
        out(flq);
        // Fill flq with a value and add it to list
        flq.fill(value);
        out(flq);
        // Add dimnames, units and data
        flq.set_dimnames(dimnames);
        flq.set_units(units);
        flq.set_data(data);
        out(flq);
        return out;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_flq_constructor>>=
# Make a dummy FLQ and see how all the bits go together
dim <- dim(flq1)
dimnames <- dimnames(flq1)
units <- units(flq1)
value <- runif(1)
data <- c(flq1)
flqs <- flq_constructor(dim, value, units, dimnames, data)
# First flq is full of 0s with no units or dimnames
dim(flqs[[1]])
dimnames(flqs[[1]])
units(flqs[[1]])
# Show a subset
flqs[[1]][1:3,1]
# Result of fill
expect_that(all(flqs[[2]]==value), is_true())
# The fully assembled FLQuant
expect_that(flqs[[3]], equals(flq1))
@


\section{Stock-recruitment relationships with \class{fwdSR}}

The \class{fwdSR} class is used to represent stock-recruitment (SR) dynamics.
It includes several members:

\begin{itemize}
    \item the SR function;
    \item the parameters of the SR function;
    \item the residuals;
    \item whether the residuals are multiplicative or not.
\end{itemize}

\subsection{The SR function}

Internally the SR function in a \class{fwdSR} object is a function pointer to one of several already included SR functions.
A \class{std::map<>} is used to select the correct function for the function pointer.
The SR functions are declared at the bottom of the \code{fwdSR.h} script and defined at the bottom of the \code{fwdSR.cpp} script.
The model map is initialised by the \code{init\_model\_map()} method which is called by the class constructor.
The arguments for the included SR functions are the same: are a single \class{T} value for Stock Reproductive Potential (SRP) (where \class{T} is either a \class{double} or an \class{adouble}), and a \class{std::vector<double} for the parameters (of length equal to the number of parameters). The function returns a single \class{T} value of recruitment.
The possibility of using an \class{adouble} was added in case we can do something exciting with fitting SR models but this hasn't been thought through yet.

Three SR functions have been written: \code{ricker()}, \code{bevholt()} and \code{constant()}. Multiple names in the model map can be mapped to the same SR function allowing for multiple spellings of the model (e.g. 'Ricker' and 'ricker').

To add a new permanent SR model to the package you have to do three things:

\begin{enumerate}
    \item Write a new SR function declaration in \code{fwdSR.h}. The function should have \textit{exactly} the same arguments as described above (see existing functions for structure).
    \item Write the function code in \code{fwdSR.cpp} (again, see existing functions for structure).
    \item Add the new function to the model map by adding lines to the \code{init\_model\_map()} method in \code{fwdSR.cpp}. The right-hand side is the name of your new function, prefixed by \code{&} (the address operator). The left-hand side is the character string that your model will be called by the user in \R (copy the existing style).
\end{enumerate}

There is the possibility of being able to write a new SR model in a live R session. The code can be written in C++, and through the use of \pkg{Rcpp} external pointers be used by \class{fwdSR}. An example of how this can be implemented is in the \pkg{funcPtrPkg}. This functionality has not yet been added to \pkg{FLasher}.

%\subsection{The time lag}
%
% REMOVED - ADD TO BIOL
%The time lag is the number of time steps between spawning and recruitment. A time step is in either year or seasons.
%The time lag is not used by the \class{fwdSR} object when calculating recruitment. It is only used by the operating model that uses the \class{fwdSR} to make sure that the correct time step of SSB is used.
%

\subsection{The SR parameters}

The parameters are stored as an \class{FLQuant}. The first dimension is used for the parameters. The other dimensions allow the parameters to vary over year, unit, season, area and iter if necessary. If the parameters are fixed in a dimension, for example if the parameters do not change with year or season, then those dimensions have length 1.
For example, in the simplest case, the \code{alpha} and \code{beta} parameters for the Ricker SR function are constant over all dimensions and so would be stored in an \class{FLQuant} with dimensions (2,1,1,1,1,1).
If the parameters do vary with one of the dimensions, they should have the same length as that dimension in the model. 
For example, if your SR parameters vary with season and there are 4 seasons in the projection model, the parameter \class{FLQuant} should have a length of 4 in the season dimension.

Note that the order of the parameters in the first dimension is the order they are passed into the SR function. In the SR function they are referenced only by position (starting at 0) not by name.

The SR parameters are passed in from \R as an \class{FLQuant} which means that if they are being taken from an \class{FLSR} object they will need to be converted from an \class{FLPar} class first.
NOTE: after developing this class, I added a C++ function to convert \class{FLPar} objects to \class{FLQuant} objects (used by \class{FLCatch}). This code could be used to pass in the SR parameters directly as an \class{FLPar} without the need for additional conversion.

\subsection{Evaluating the SR function with the SR parameters}

To evaluate the SR function the \code{eval\_model()} method is used. This takes a single value of the SSB (as either a \class{double} or an \class{adouble}) plus indices for the year to iter dimension. The dimension indices are passed in to select the correct SR params from the \code{params} member. A single value of recruitment, of the same type as SSB, is returned.
Note that the dimension indices start from 1 and cannot be passed as names. For example, if your SR parameters varied with year and had a year range of 2000 to 2010, to evaluate the recruitment in year 2005, the year argument to \code{eval\_model()} would be 6.

If you try to access SR parameters outside of their range, then an index value of 1 is used and no error is thrown. For example, if your SR params only have one year and you ask for year 10, year 1 is used.

The \code{eval\_model()} method only processes one SRP value at a time, i.e. you cannot pass a vector of SRP values.
Also, the method does not apply residuals. These are dealt with after \code{eval\_model()} has been called. BY THE PREDICT METHOD


\subsection{Residuals}

Residuals are stored as an \class{FLQuant}. No check is made in the constructors that the residuals are the right size (i.e. are the same size as the other objects in your operating model).
% but if you try to access the residuals outside of their range then it will fail nicely with a message. NOT REALLY TRUE. IT WILL JUST FAIL WITH AN OUT OF RANGE FLQUANT MESSAGE

The residuals are accessed by the \code{get\_residuals()} method.

The residuals are not applied by the \code{eval\_model()} as this method was really designed to \textit{only} evaluate the SR function, for a given SRP at a particular timestep, area etc. 

%They are just there for you to use them as you want. The same is true for the member which stores if the residuals are multiplicative or not (accessed throught the \code{get\_residuals\_mult()} method).
%For example, in the \code{project\_timestep()} method of the \class{operatingModel} class, the recruitment is first calculated given the SSB, then the residuals are applied by hand.
% ADD PREDICT METHOD


\subsection{Creating and using a \class{fwdSR}}
\label{sec:usingfwdSR}

Here we give some simple examples that illustrate how the \class{fwdSR} class works.
At the moment it is not particularly useful to use the class outside of an operating model. This could change if fitting models using automatic differentiation becomes a feature.

There is no implict \code{as<>} or \code{wrap<>} code for the \class{fwdSR} class because the class does not exist in FLR, only in the C++ code (Note: you could write an \code{as<>} that is based on a \class{list} of components but I didn't see the advantage as you will still have to compile the list of components yourself. Same goes for \code{wrap<>}. We don't need to return an \class{fwdSR} object to \R, except for testing, so there was no point in writing in a proper \code{wrap<>} method (one exists for testing purposes only)).

Instead we need to call the \class{fwdSR} constructor with the right arguments.
These are:

\begin{itemize}
    \item The name of the model as a character string. The model should be in the model map, otherwise the call to the constructor will fail.
    \item The SR parameters as an \class{FLQuant}.
    \item The residuals. An \class{FLQuant} for which dimensions 2 to 6 are of the same size as the other objects in the operating model.
    \item A boolean to describe if the residuals are multiplicative (TRUE) or additive (FALSE).
\end{itemize}

It may be possible to make one from an \class{FLSR} object so if you want to write the code, please do.

First we write a simple wrapper function to the \class{fwdSR} constructor in C++ that evaluates the model with the passed in value of SSB at a particular time step, unit etc.
This is taken from the test suite for \class{fwdSR}.

<<access_fwdsr_constructor>>=
source = '
    double test_fwdSR_eval(std::string model_name, const FLQuant params, const FLQuant residuals, const bool residuals_mult, const double srp, const std::vector<unsigned int> param_indices){
        fwdSR fwdsr(model_name, params, residuals, residuals_mult);
        double rec = fwdsr.eval_model(srp, param_indices);
        return rec;
}
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

\subsubsection{A simple example with fixed parameters and annual timestep}

Now we show how to construct a simple Ricker SR function with parameters that do not vary in time.

<<get_fwdsr_bits>>=
data(ple4)
# Fit a Ricker to the data so we can get the parameters.
ple4_sr_ricker <- fmle(as.FLSR(ple4,model="ricker"), control  = list(trace=0))
# The parameters are in the params slot
# Turn them into an FLQuant 
params <- as.FLQuant(params(ple4_sr_ricker))
# Look at the params
dimnames(params)
# The first dimension is for the parameters a and b.
# Dimensions 2 to 6 are of length 1 and are for year, season etc.
# We don't use the residuals in this example but we need them for the fwdSR constructor so must be included.
# Get the residuals - thay are already an FLQuant
residuals <- residuals(ple4_sr_ricker)    
# These are multiplicative on the log scale
residuals_mult <- TRUE
# Finally we need a value of SRP 
# Here we use SSB as a measure of SSB.
# Just pull out the SSB in the first year of ple4 and make it a single numeric
ssb <- c(ssb(ple4)[,1])
# Eval the function for the first year, unit, season etc.
param_indices <- c(1,1,1,1,1)
test_fwdSR_eval('ricker', params, residuals, residuals_mult, ssb, param_indices)
# Is this value right? Use the FLR method to check
predict(ple4_sr_ricker, ssb=FLQuant(ssb))
@

\subsubsection{An example with a seasonal timestep}

In this example, the SR parameters are still fixed in time and other dimensions (2 to 5) but the timestep of the model is seasonal
with 4 seasons.
If the season dimension of the SR parameters is of length 1 then the same parameter values will be used for all seasons.
The projection methods in \pkg{FLasher} evaluate the SR model \textit{at every time step}.
This means that if the season dimension of the SR parameters is of length 1, the stock will effectively recruit at every time step.
This is probably not what you want. We deal with this below. 

Here is an example to demonstrate this behaviour using the objects created above. We only have 1 season in the SR params and consequently this is used for all seasons that the SR mode is evaluated:

<<fwdsr_bad_season_example>>=
# Evaluate the value in season 1
test_fwdSR_eval('ricker', params, residuals, residuals_mult, ssb, c(1, 1, 1, 1, 1))
# Evaluate the value in season 2
test_fwdSR_eval('ricker', params, residuals, residuals_mult, ssb, c(1, 1, 2, 1, 1))
# Evaluate the value in season 3
test_fwdSR_eval('ricker', params, residuals, residuals_mult, ssb, c(1, 1, 3, 1, 1))
# Evaluate the value in season 4
test_fwdSR_eval('ricker', params, residuals, residuals_mult, ssb, c(1, 1, 4, 1, 1))
@

If you have a seasonal model and your stock only recruits in one season (or not in every season), your SR parameters should be seasonally disaggregated and the values set so that recruitment in the non-recruitment seasons is zero.

In the following example, the stock only recruits in season 2.
We set up an \class{FLQuant} for the parameters, but set the parameter values to 0 in seasons 1, 3 and 4.

<<fwdsr_season_2_example>>=
# Set up some parameters so that only the values in season 2 are not 0
season_params <- FLQuant(0, dimnames=list(params = c('a', 'b'), season = 1:4))
season_params[,,,2] <- c(params(ple4_sr_ricker))
season_params
# Evaluate the value in season 1
test_fwdSR_eval('ricker', season_params, residuals, residuals_mult, ssb, c(1, 1, 1, 1, 1))
# Evaluate the value in season 2
test_fwdSR_eval('ricker', season_params, residuals, residuals_mult, ssb, c(1, 1, 2, 1, 1))
# Evaluate the value in season 3
test_fwdSR_eval('ricker', season_params, residuals, residuals_mult, ssb, c(1, 1, 3, 1, 1))
# Evaluate the value in season 4
test_fwdSR_eval('ricker', season_params, residuals, residuals_mult, ssb, c(1, 1, 4, 1, 1))
# Evaluate the value in season 5 - even though there is no season 5
test_fwdSR_eval('ricker', season_params, residuals, residuals_mult, ssb, c(1, 1, 5, 1, 1))
# If the season you ask for is not in the params, it just uses season 1
# This is potentially dangerous! 
@

So now even though the projection method evaluates the SR function at every timestep, the effective recruitment in the timesteps where the stock does not recruit is 0.

\subsubsection{An example with parameters changing over time}

To have the SR params change over time / unit / iter etc., simply set up the \class{FLQuant} of parameters to reflect that.

<<fwdsr_year_example>>=
year_params <- FLQuant(NA, dimnames=list(params = c('a', 'b'), year = 1:10))
# b parameter is constant in time but a parameter increases (for whatever reason)
year_params['b',] <- params['b']
year_params['a',] <- c(params['a']) * seq(from=1, to = 1.5, length=10)
year_params

# Evaluate the value in year 1
test_fwdSR_eval('ricker', year_params, timelag, residuals, residuals_mult, ssb, 1, 1, 1, 1, 1)
# Evaluate the value in year 2 with the same SSB
test_fwdSR_eval('ricker', year_params, timelag, residuals, residuals_mult, ssb, 2, 1, 1, 1, 1)
# Evaluate the value in year 3 with the same SSB
test_fwdSR_eval('ricker', year_params, timelag, residuals, residuals_mult, ssb, 3, 1, 1, 1, 1)
# And so on
@

As mentioned above, if you try to access a year or season or whatever that is not in the SR params (i.e. you have gone outside the bounds of the \class{FLQuant}) then the params in position 1 are used.


\section{\class{fwdBiol}}
\label{sec:fwdBiol}

\subsection{Introduction}

The C++ class \class{fwdBiol} is essentially the same as the \R class \class{FLBiol} except it also contains SR information. It has an additional private member \code{srr} to hold an \class{fwdSR} object.
The \class{fwdBiol} class has the same slots as an \class{FLBiol}.
A 'list' class, \class{fwdBiols} is also available (see Section~\ref{sec:fwdBiols}).

A \class{double} and an \class{adouble} version of \class{fwdBiol} are available (called \class{fwdBiol} and \class{fwdBiolAD} respectively). For the \class{adouble} version, only the abundances in the \code{n} member and the \class{fwdSR} member are of type \class{adouble}. The other members (mean weight at age, maturity etc) are \class{double}.

Note that the \class{fwdBiol} class is a \code{friend} of the \class{operatingModel} class. This is so the \class{operatingModel} can access the \class{fwdSR} member directly. It is probably a sign of bad design.
It might be useful to add an \code{eval\_sr()} method to the \class{fwdBiol} class.

\subsection{Making an \class{fwdBiol}}

There is an implicit \code{as<>} for \class{fwdBiol} but it only works on an \class{FLBiol} and ignores the SRR component. It is therefore of limited use.
Instead it is necessary to use the class constructor which takes an \class{FLBiol} (as an SEXP) and either an \class{fwdSR} or the components used to make an \class{fwdSR}.
There is also an implict \code{wrap<>} but it only returns an \class{FLBiol} and strips out the SRR component.

<<fwdbiol_constructor>>=
source = '
    fwdBiol test_fwdBiol(SEXP flbiol, std::string model_name, FLQuant params, int timelag, FLQuant residuals, bool residuals_mult){
        // Pass in the FLBiol (as an SEXP) plus the bits that make up the SRR
        fwdBiol biol1(flbiol, model_name, params, timelag, residuals, residuals_mult);
        // Or make the fwdSR then make the fwdBiol
        fwdSR sr(model_name, params, timelag, residuals, residuals_mult);
        fwdBiol biol2(flbiol, sr);
        // Return it back to R but loses SRR part
        return biol2;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_fwdbiol_constructor>>=
# Make an FLBiol out of ple4
data(ple4)
ple4_biol <- as(ple4, "FLBiol")
# Pass into the constructor function with the SRR bits from above
biol_out <- test_fwdBiol(ple4_biol, 'ricker', year_params, timelag, residuals, residuals_mult)
is(biol_out)
# It's an FLBiol, same as the one we out in, and we have lost the SRR bits
expect_that(biol_out, equals(ple4_biol))
@

\subsection{Using an \class{fwdBiol}}

The above example is pretty limited because even though we created an \class{fwdBiol} object we didn't do anything with it.
As expected, you an access all the members (slots) of an \class{fwdBiol} to read and write the values.
Access is through accessor methods which have the same name as the slots in an \class{FLBiol} (e.g. \code{n()}, \code{wt()} etc).
These methods access an entire \class{FLQuant}.
To access the values in the \class{FLQuant} you can use methods in Section~\ref{sec:flquantaccess}.
However, to access an individual value, you first need to get at the whole \class{FLQuant}, and then access the value, requiring an additional set of brackets (Note: this could be fixed by writing additional accessors).
Alternatively, the accessor methods also work by passing in vectors of indices to subset the \class{FLQuant}. This method only works for reading values, not writing them.

<<fwdbiol_accessor>>=
source = '
    FLQuant test_fwdBiol(SEXP flbiol, std::string model_name, FLQuant params, int timelag, FLQuant residuals, bool residuals_mult, double value, std::vector<unsigned int> indices_min, std::vector<unsigned int> indices_max){
        // Make the fwdBiol
        fwdBiol biol(flbiol, model_name, params, timelag, residuals, residuals_mult);
        // Pull out the whole FLQuant of abundances
        FLQuant abund = biol.n();
        // Pull out first value from the abundances
        double val1 = abund(1,1,1,1,1,1);
        // Or do it all in 1 stage - note the extra ()
        double val2 = biol.n()(1,1,1,1,1,1);
        // Write a single value - again note the extra ()
        biol.n()(1,1,1,1,1,1) = value;
        // Subset a member FLQuant - read only
        FLQuant n_subset = biol.n(indices_min, indices_max);
        return n_subset;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_fwdbiol_accessor>>=
indices_min <- c(1,1,1,1,1,1)
indices_max <- c(4,4,1,1,1,1)
value <- 666
out <- test_fwdBiol(ple4_biol, 'ricker', year_params, timelag, residuals, residuals_mult, value, indices_min, indices_max)
# It's the subsetted n slot, with the first value changed
out 
@

\subsection{Other methods}

As well as just accessing the data in the \class{fwdBiol} there are also other methods.
Actually, there is really just one at the moment, but the potential is there for more.

The \code{biomass()} method returns the calculation of mean weight at age multiplied by the abundance at age, summed over the first dimension.
You can call the method with no arguments, which calculates over the whole \class{FLQuant}s, or you can pass in minimum and maximum indices to subset the biomass as it is calculated. Unlike when subsetting a normal \class{FLQuant}, because we know the size of the first dimension of the biomass is always 1 (we have collapsed this dimension) the vectors of indices are only of length 5 (to index dimensions 2 to 6).
This method is faster than calculating the biomass of the whole \class{FLQUant} and then subsetting.

Both methods are illustrated here (we ignore the SR components for simplicity).

<<fwdbiol_biomass>>=
source = '
    FLQuant7 test_fwdBiol_biomass(fwdBiol flb, std::vector<unsigned int> indices_min, std::vector<unsigned int> indices_max){
        FLQuant biomass1 = flb.biomass();
        FLQuant biomass2 = flb.biomass(indices_min, indices_max);
        FLQuant7 flqs(biomass1);
        flqs(biomass2);
        return flqs;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_fwdbiol_biomass>>=
indices_min <- c(1,1,1,1,1)
indices_max <- c(4,1,1,1,1)
flqs <- test_fwdBiol_biomass(ple4_biol, indices_min, indices_max)
# The whole FLQuant (show the first 4 years)
quantSums(n(ple4_biol) * wt(ple4_biol))[,1:4]
flqs[[1]][,1:4]
# Using the subset method
flqs[[2]]
@


\section{\class{fwdBiols}}
\label{sec:fwdBiols}

\section{Basic use}

The \class{fwdBiols} class is a \code{std::vector} of \class{fwdBiol} objects. The use is simple. You can add additional objects to the list and access them through the \code() operator (indices start at 1, not 0).
This class is used in the \class{operatingModel} class to store the biological information of the stocks.

In this example we pass in two \class{FLBiol} objects and make \class{fwdBiol} objects from them using the intrinsic \code{as<>} (which neglects the SR components). The two objects are placed in a \class{fwdBiols} object which is then returned. The returned object is an \class{FLBiols}. 

<<fwdBiols_make>>=
source = '
    fwdBiols test_fwdBiols(fwdBiol biol1, fwdBiol biol2){
        // Make a list of fwdBiol objects
        fwdBiols biols(biol1);
        biols(biol2);
        return biols;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_fwdBiols_make>>=
# Make two identical biols
data(ple4)
ple4_biol1 <- as(ple4, "FLBiol")
ple4_biol2 <- as(ple4, "FLBiol")
biols <- test_fwdBiols(ple4_biol1, ple4_biol1)
is(biols)
@

The method \code{get\_nbiols()} returns the number of \class{fwdBiol} objects in the \class{fwdBiols}.

As mentioned above, the individual \class{fwdBiol} objects are accessed using the \code{()} accessor and the index within the vector (starting at 1). It is not possible to access the \class{fwdBiol} objects by name (they are not named in the vector).

%You can also pass in an \code{FLBiols} object and make an \code{fwdBiols} object using the intrinsic \code{as<>}. NO YOU CAN'T. SHOULD DO

The following example demonstrates this, and also how to access the objects in the \class{fwdBiol} (you can write an object as well as read).

<<fwdBiols_access>>=
source = '
    fwdBiol test_fwdBiols_accessor(fwdBiol biol1, fwdBiol biol2){
        // Make the fwdBiols object
        fwdBiols biols(biol1);
        biols(biol2);
        // Pull out second fwdBiol from fwdBiols
        fwdBiol biol = biols(2);
        return biol;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_fwdBiols_access>>=
out <- test_fwdBiols_accessor(ple4_biol1, ple4_biol2)
# It's an FLBiol
is(out)
@

\subsection{Making an \class{fwdBiols} object from a list of components}

We saw above that you can make an \class{fwdBiol} object from an \class{FLBiol} and the SRR components.
As well as making an \class{fwdBiols} object from individual, already constructed \class{fwdBiol} objects, you can make it from a list.
Each element of the list is also a list which contains elements needed to make a single \class{fwdBiol}:

\begin{itemize}
    \item An \class{FLBiol}, called 'biol';
    \item A character string of the SRR model name called 'srr\_model\_name';
    \item An \class{FLQuant} of residuals called 'srr\_residuals';
    \item An integer for the time lag, called 'srr\_timelag';
    \item An \class{FLQuant} of parameters called 'srr\_params';
    \item A boolean t describe if the residuals are multiplicative called 'srr\_residuals\_mult'
\end{itemize}

The order of the items in the list is not important, but the names are.
The list of lists must also have names.

Internally, all these elements are used to make \class{fwdBiol} objects which are then added to the \class{fwdBiols} object.
The SRR components (elements 2 - 6 in the above list) are used to make the \class{fwdSR} object, as described above.

This is all a bit of a faff so please feel free to come up with a better way.

<<fwdBiols_constructor>>=
source = '
    fwdBiol test_fwdBiols_constructor(SEXP biols_list){
        // Make the fwdBiols object
        fwdBiols biols(biols_list);
        // Pull out second fwdBiol from fwdBiols
        fwdBiol biol = biols(2);
        return biol;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

Test this with the objects we created above.

<<fwdBiols_constructor_test>>=
# Make a list of fwdBiol bits
biol_bits <- list(biol = ple4_biol,
                   srr_model_name = 'ricker',
                   srr_params = year_params,
                   srr_residuals = residuals,
                   srr_residuals_mult = residuals_mult,
                   srr_timelag = timelag)
# Make a list with identical components - give them names
biols <- list(biol1 = biol_bits, biol12 = biol_bits)
# Test the constructor
biol_out <- test_fwdBiols_constructor(biols)
@

\section{\class{FLCatch}}
\label{sec:FLCatch}

\subsection{Introduction}

The C++ class \class{FLCatch} attempts to replicate the FLR class \class{FLCatch} with the same members / slots.
The \class{FLQuant} members are accessed using the same style of accessor methods as with \class{fwdBiol}: either by pulling out the whole \class{FLQuant} and then accessing a single value, or by subsetting the \class{FLQuant} member.

Intrinsic \code{as<>} and \code{wrap<>} methods have been written to make passing \class{FLCatch} objects between \R and C++ straightforward.
There is no other constructor for the C++ version \class{FLCatch} other than passing in one from R. Feel free to add one if you want.

\class{double} and \class{adouble} versions of the class are available, called \class{FLCatch} and \class{FLCatchAD} respectively.

In this example we pass in an \class{FLCatch} from R, change a value in the landings numbers, and return the changed \class{FLCatch}.

<<FLCatch_access>>=
source = '
    FLCatch test_FLCatch(FLCatch flc){
        // Change a value in the landings
        flc.landings_n()(1,1,1,1,1,1) = 666;
        return flc;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_FLCatch_access>>=
data(ple4)
ple4_catch <- as(ple4, "FLCatch")
# Need to set something for desc and name slots
ple4_catch@desc <- "something"
ple4_catch@name <- "something"
out <- test_FLCatch(ple4_catch)
is(out)
# Landings are the same except the value we changed
landings.n(ple4_catch)[1:4,1:4]
landings.n(out)[1:4,1:4]
@

\subsection{Difference with the discards ratio}

One thing to note is that the C++ version has a member to store the discards ratio (called \code{discards\_ratio}).
This is equal to (discards\_n / (discards\_n + landings\_n). It is calculated when the object is first created.
In the FLR version of \class{FLCatch}, \code{discards.ratio()} is a method. It is not a method in the C++ version
because when solving for a target the landings and discards members may be written over.
Consquently when the final projection is done, the \textit{calculated} discards ratio may not be what the user intends.
It was considered safer to store values when they are passed in and that used instead.

\subsection{Catchability parameters}

In an FLR \class{FLCatch} the catchability parameters are stored as an \class{FLPar}. There is no \class{FLPar} class in the C++ classes because the dimensions need to be fixed.
Instead, an \class{FLQuant} is used, similar to the way one is used to store the SR params in a \class{fwdSR}. The parameters are stored in the first dimension.
The \class{operatingModel} class currently assumes that the there will be two parameters: alpha and beta, stored in position 1 and 2 along the first dimension respectively.
The parameters \class{FLQuant} does not have the same dimensions as the other \class{FLQuant} members.
It has dimensions that are of the same length as the ones in the \class{FLPar}.
There is a function in the FLQuant\_base.cpp script that attempts to convert an \class{FLPar} to an \class{FLQuant}. Not of all the \class{FLQuant} dimensions from 2 to 6 need to be in the \class{FLPar} but those that are need to be in the right order, e.g. year before unit.

There are (currently) three accessors for the catchability parameters. The first one takes no arguments and just returns the \class{FLQuant}. The second one takes indices for the year, unit etc. and returns the parameter values along the first dimension for that year, unit etc. If you ask for a year or other dimension that is outside the range of the \class{FLQuant} then the value at index 1 is returned. For example, if you only have 1 year of data and you ask for year 4, you will get back year 1. The third method is a subset method using two vectors of indices (similar to other subset methods in FLCpp). The method builds an \class{FLQuant} of the appropriate size and populates according to the rules of the second method. The second and third method are read only and cannot be used to write values.

This all sounds complicated but it isn't. It's best illustrated by an example. Here we use all three methods to extract the parameter values and return them as a list to \R.
However, it should be noted that these methods are all intended to be used internally and are not really for normal consumption.

<<FLCatch_access_q>>=
source = '
    Rcpp::List test_FLCatch_q(FLCatch flc, std::vector<unsigned int> indices_min, std::vector<unsigned int> indices_max){
        FLQuant params1 = flc.catch_q_params();
        std::vector<double> params2 = flc.catch_q_params(4,1,1,1,4);
        FLQuant params3 = flc.catch_q_params(indices_min, indices_max);
        return Rcpp::List::create(Rcpp::Named("method1") = params1,
                                  Rcpp::Named("method2") = params2,
                                  Rcpp::Named("method3") = params3);
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_FLCatch_access_q>>=
data(ple4)
ple4_catch <- as(ple4, "FLCatch")
# Need to set something for desc and name slots
ple4_catch@desc <- "something"
ple4_catch@name <- "something"
# Make the params
catch.q(ple4_catch) <- FLPar(c(0.5,0.1), dimnames=list(param = c('alpha', 'beta'), iter = 1))
# Subset indices to include both params and years 1 to 4
indices_min <- c(1,1,1,1,1,1)
indices_max <- c(2,4,1,1,1,1)
out <- test_FLCatch_q(ple4_catch, indices_min, indices_max)
# The parameters as an FLQuant
out[["method1"]]
# The parameter values (at a year and iter range outside of the original range)
out[["method2"]]
# Subset and create a new FLQuant of the required size outside of the original range
out[["method3"]]
@

\subsection{Other methods}

Do landings methods take indices of length 5 or 6?

Several methods are available for the \class{FLCatch} class that are not just accessors. There names are pretty self-explanatory:

The methods \code{catch\_n()} and \code{catch\_wt()} calculate the abundances and mean weight at age in the catch from the appropriate \code{landings} and \code{discards} members, similar to the FLR versions of these methods.
If no arguments are passed, values for the whole \class{FLQuant} are calculated (which can then be accessed to read / write individual values).
Alternatively, you can pass minimum and maximum indices to subset. This is faster.

The methods \code{catches()} (not \textit{catch} as that is a reserved word in C++), \code{landings()} and \code{discards()} do as you would expect, summing the product of the abundances and mean weights at age. Again, if no arguments are passed, the whole \class{FLQuant} is calculated and the individual values accessed.
Alternatively, you can pass minimum and maximum indices to subset. If you pass indices, the vectors are of length 5, not 6, as we do not subset the first dimension (e.g. age) which is collapsed in the calculation.

The methods \code{landings\_sel()} and \code{discards\_sel()} perform the same calculation as the FLR equivalents. At the moment, the methods take no arguments and the whole \class{FLQuant} is calculated. No subsetting methods currently exist.


<<FLCatch_methods>>=
source = '
    FLQuant7 test_FLCatch_methods(FLCatch flc, std::vector<unsigned int> indices_min_age, std::vector<unsigned int> indices_max_age, std::vector<unsigned int> indices_min, std::vector<unsigned int> indices_max){
        FLQuant cn1 = flc.catch_n();
        FLQuant cn2 = flc.catch_n(indices_min_age, indices_max_age);
        FLQuant cw1 = flc.catch_wt();
        FLQuant cw2 = flc.catch_wt(indices_min_age, indices_max_age);
        FLQuant catch1 = flc.catches();
        FLQuant catch2 = flc.catches(indices_min, indices_max);
        FLQuant landings1 = flc.landings();
        FLQuant landings2 = flc.landings(indices_min, indices_max);
        FLQuant discards1 = flc.discards();
        FLQuant discards2 = flc.discards(indices_min, indices_max);
        FLQuant lsel = flc.landings_sel();
        FLQuant dsel = flc.discards_sel();
        // Put all the results together
        FLQuant7 flqs(cn1);
        flqs(cn2);
        flqs(cw1);
        flqs(cw2);
        flqs(catch1);
        flqs(catch2);
        flqs(landings1);
        flqs(landings2);
        flqs(discards1);
        flqs(discards2);
        flqs(lsel);
        flqs(dsel);
        return flqs;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_FLCatch_methods>>=
data(ple4)
ple4_catch <- as(ple4, "FLCatch")
# Need to set something for desc and name slots
ple4_catch@desc <- "something"
ple4_catch@name <- "something"
indices_min_age <- c(1,1,1,1,1,1)
indices_max_age <- c(4,4,1,1,1,1)
indices_min <- c(1,1,1,1,1)
indices_max <- c(4,1,1,1,1)
flqs_out <- test_FLCatch_methods(ple4_catch, indices_min_age, indices_max_age, indices_min, indices_max)
# Compare the results
# Catch numbers
catch.n(ple4_catch)[1:4, 1:4]
flqs_out[[1]][1:4, 1:4]
flqs_out[[2]]
# Catch wts
catch.wt(ple4_catch)[1:4, 1:4]
flqs_out[[3]][1:4, 1:4]
flqs_out[[4]]
# Catch total
catch(ple4_catch)[, 1:4]
flqs_out[[5]][, 1:4]
flqs_out[[6]]
# Landings total
landings(ple4_catch)[, 1:4]
flqs_out[[7]][, 1:4]
flqs_out[[8]]
# Discards total
discards(ple4_catch)[, 1:4]
flqs_out[[9]][, 1:4]
flqs_out[[10]]
# Landings sel
landings.sel(ple4_catch)[1:4, 1:4]
flqs_out[[11]][1:4, 1:4]
# Discards sel
discards.sel(ple4_catch)[1:4, 1:4]
flqs_out[[12]][1:4, 1:4]
@

\section{\class{FLCatches}}

There is a plural class for \class{FLCatch} objects called \class{FLCatches}.
It works pretty much as the \class{fwdBiols} class works by using the \code{()} accessor to access the individual \class{FLCatch} objects.
The class is used to store the \class{FLCatch} objects inside the \class{FLFishery} class.
Intrinsic \code{as<>} and \code{wrap<>} methods have been written to allow \class{FLCatches} to be passed from R to C++.
There is a method that returns the number of catches in object: \code{get\_ncatches()}.
\code{double} and \code{adouble} versions of this class (called \class{FLCatches} and \class{FLCatchesAD} respectively) are used to store the corresponding \class{FLCath} types. The types cannot be mixed.

It would be straightforward to add iterators for this class if you wanted.

\section{\class{FLFishery}}

The \class{FLFishery} class in C++ is an implementation of the FLR class \class{FLFishery}.
Implicit \code{as<>} and \code{wrap<>} methods have been written to allow \class{FLFishery} objects to be easily passed to and from \R / C++.

Internally, the \class{FLFishery} class is derived from the \class{FLCatches} class. As such, the \class{FLFishery} essentially \textit{is} an \class{FLCatches} but with some extra members to hold effort, variable costs and fixed costs. These are stored as \class{FLQuant}s. The \class{FLCatch} objects are accessed through the \code{()} accessor, with the index starting at 1.

\code{double} and \code{adouble} versions are available (called \class{FLFishery} and \class{FLFisheryAD} respectively) depending on the type of the \class{FLCatches} that it is derived from.

At the moment, there is no way of making an \class{FLFishery} from scratch inside C++. Instead, you need to pass one in from R.

\subsection{Using an \class{FLFishery}}

Here we show an example of passing in an \class{FLFishery} with two \class{FLCatch} objects from \R, changing a value in the \code{landings\_n} member of the second \class{FLCatch}, and returning the changed \class{FLFishery}.

<<FLFishery_as>>=
source = '
    FLFishery test_FLFishery(FLFishery flf){
        // Change landings_n in the second FLCatch - note the brackets
        flf(2).landings_n()(1,1,1,1,1,1) = 666;
        return flf;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<FLFishery_test_as>>=
# Use the random generator from the test_helper_functions.R
flf_in <- random_FLFishery_generator(max_catches = 2)
is(flf_in)
length(flf_in)
flf_out <- test_FLFishery(flf_in)
landings.n(flf_in[[2]])[,1,1,1,1,1]
landings.n(flf_out[[2]])[,1,1,1,1,1]
@

You can, of course, subset the members of the \class{FLCatch}, as seen in Section~\ref{sec:FLCatch}.
Here we subset the catch abundances (which are not directly stored in the object but calculated from the \code{landings\_n} and \code{discards\_n} members).

<<FLFishery_subset>>=
source = '
    FLQuant test_FLFishery_indices(FLFishery flf, std::vector<unsigned int> indices_min, std::vector<unsigned int> indices_max){
        // Change landings_n in the second FLCatch - note the brackets
        FLQuant flq = flf(2).catch_n(indices_min, indices_max);
        return flq;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<FLFishery_test_subset>>=
indices_min <- c(1,1,1,1,1,1)
indices_max <- pmax(dim(landings.n(flf_in[[2]])) - 1, c(1,1,1,1,1,1))
flq_out <- test_FLFishery_indices(flf_in, indices_min, indices_max)
# Bit faffy subsetting the original object
flq_in <- catch.n(flf_in[[2]])[indices_min[1]:indices_max[1],
    indices_min[2]:indices_max[2],
    indices_min[3]:indices_max[3],
    indices_min[4]:indices_max[4],
    indices_min[5]:indices_max[5],
    indices_min[6]:indices_max[6]]
expect_that(flq_in, equals(flq_out))
@

The \code{effort} member is accessed through the \code{effort()} accessor. This behaves the same as the other \class{FLQuant} accessors. You can either read and write an individual value, or pull out a subset using indices.
Here we set the effort in the first year.

<<FLFishery_effort>>=
source = '
    FLFishery test_FLFishery_effort(FLFishery flf){
        // Change effort in the first year etc - note the extra brackets
        flf.effort()(1,1,1,1,1,1) = 666;
        return flf;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_FLFishery_effort>>=
flf_out <- test_FLFishery_effort(flf_in)
effort(flf_in)[,1:dim(effort(flf_in))[2],1,1,1,1]
effort(flf_out)[,1:dim(effort(flf_out))[2],1,1,1,1]
@



\section{\class{FLFisheries}}

The big one. The C++ class is pretty much the same as the FLR class. It's really just a \code{std::vector<>} of \class{FLFishery} objects.

As with \class{FLFishery}, implicit \code{as<>} and \code{wrap<>} methods have been written to allow \class{FLFisheries} objects to be easily passed to and from \R / C++.
\code{double} and \code{adouble} versions are available (called \class{FLFisheries} and \class{FLFisheriesAD} respectively) depending on the type of the \class{FLFishery} that it contains. The \class{operatingModel} class uses \class{FLFisheriesAD} to hold all of the fisheries information.

At the moment, there is no way of making an \class{FLFisheries} from scratch inside C++. Instead, you need to pass one in from R.

The \class{FLFishery} objects are accessed through the \code{()} accessor, with the index starting at 1.
To access an \class{FLCatch} inside an \class{FLFishery} that is inside an \class{FLFisheries} you can either use two sets of \code{()} with a single index inside each \code{()} (for the \class{FLFishery} and \class{FLCatch} respectively), or you can pass two index values into a single set of \code{()} (again for the \class{FLFishery} and \class{FLCatch} respectively).
This does mean that when accessing a particular value in a member of an \class{FLCatch} you can end up with some clumsy looking code. Sorry.

When you have drilled down into the chosen \class{FLCatch}, you can just use the regular accessors from Section~\ref{sec:FLCatch} to read and write the data etc.

Here is an example using a randomly generated FLFisheries object.

<<FLFisheries_example>>=
source = '
    FLFisheries test_FLFisheries(FLFisheries flfs){
        // Pull out a whole FLFishery
        FLFishery flf = flfs(1);
        // Pull out a whole FLCatch using 2 sets of ()
        FLCatch flc1 = flfs(1)(1);
        // Or 1 set o ()
        FLCatch flc2 = flfs(1,1);
        // Change a value in the landings_n of an FLCatch
        flfs(1,1).landings_n()(1,1,1,1,1,1) = 666;
        return flfs;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<test_FLFisheries_example>>=
flfs_in <- random_FLFisheries_generator(max_fisheries = 2)
flfs_out <- test_FLFisheries(flfs_in)
landings.n(flfs_in[[1]][[1]])[,1,1,1,1,1]
landings.n(flfs_out[[1]][[1]])[,1,1,1,1,1]

@

Tada


\section{\class{FLStock}}

There is a C++ implentation of the \class{FLStock} class. However, it is not actually used in the \class{operatingModel} class and consequently is not currently used very much and is not as well as developed as the other classes.
Only a \code{double} version is available (adding an \code{adouble} version would be straightforward.

The \class{FLQuant} members are public, not private (although the data inside the \class{FLQuant} is still private).
This makes the code to access the members slightly simpler because you do not need the extra \code{()}.
However, it is generally considered good practice to make your data members private, strengthing the encapsulation and making the code safer.
% But it has led to faffy code with the extra () and probably inefficient running - atm to access a single value you need to pull out the whole FLQ
% then access the value, rather than just going at it directly.
% And when is having the FLQ members public unsafe? Seeing as we offer a whole 'get' method with () anyway. At the moment those get and set methods are the same thing as making the members public anway. 
% To actually make it safe, and fast, would be to remove the get / set () methods entirely and write proper accessor methods i.e. lots of (,,,,,,) methods
% But this seems like a faff 
% The idea behind not making them public is that if the structure of the FLR classes changes, the OM code will still work (the class code will need changing of course). The same reason we don't use @ in R, we use the accessor
% This is important as the FLFishery class is still fluid


Intrinsic \code{as<>} and \code{wrap<>} methods have been written and allow the easy passing of \class{FLStock} objects between R and C++.

<<FLStock>>=
source = '
    FLStock test_FLStock(FLStock fls){
        FLQuant ca = fls.catches;
        // Public members means you can access the members directly
        fls.catches(1,1,1,1,1,1) = 666;
        fls.catches.set_units("test");
        return fls;
    }
'
cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
@

<<FLStock_test>>=
data(ple4)
out <- test_FLStock(ple4)
catch(out)[1,1:4]
@


%<<fwb>>=
%source = '
%    fwdBiol fwbt(fwdBiol fwb){
%        // Not allowed
%        //fwb.n(1,1,1,1,1,1) = 666;
%        // Need to use extra () - probably slower
%        fwb.n()(1,1,1,1,1,1) = 666;
%        // And using the get () method does the same anyway - we still get full access the FLQ - no difference
%        fwb.n().set_units("test");
%        return fwb;
%    }
%'
%
%cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
%@
%
%<<>>=
%bin <- as(ple4, "FLBiol")
%bout <- fwbt(bin)
%n(bout)
%@


%\section{Automatic differentiation}

%<<flquant_constructor>>=
%source = '
%     std::vector<double> my_func(double x, double y){
%         std::vector<double> out(1);
%         out[0] = x + y;
%         return out;
%    }
%'
%cppFunction(code=source, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
%
%# Function that calls my func
%source2 = '
%     std::vector<double> my_calling_func(double x, double y, SEXP func){
%         // Can we see my_func? - no
%         std::vector<double> out;
%        Rcpp::Function my_func(func);
%
%
%         out = my_func(x,y);
%         return out;
%    }
%'
%cppFunction(code=source2, depends = 'FLasher', plugins='cpp11', rebuild=TRUE)
%
%my_calling_func(10.0, 12.0, my_func)


%@




\end{document}

