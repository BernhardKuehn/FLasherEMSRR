\documentclass[a4paper,english,10pt]{article}
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{FLCpp}
%\VignetteKeywords{R,FLR,Rcpp}
%\VignettePackage{FLasher}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{color} 
\usepackage{float}
\usepackage{longtable}
\usepackage[bottom]{footmisc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{authblk}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{babel}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{verbose,a4paper,tmargin=3cm,bmargin=2cm,lmargin=2cm,rmargin=3cm}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,        % color of internal links
    citecolor=red,         % color of links to bibliography
    filecolor=blue,        % color of file links
    urlcolor=blue          % color of external links
}

% Define some handy formatting
\newcommand{\initiative}[1]{{\texttt{#1}}}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\pkg}[1]{{\texttt{#1}}}
\newcommand{\class}[1]{{\textit{#1}}}
\newcommand{\R}{{\normalfont\textsf{R }}{}}
\newcommand{\args}[1]{{\texttt{#1}}}
\newcommand{\E}[1]{\text{E}\left[#1\right]}
\newcommand{\Var}[1]{\text{Var}\left[#1\right]}


%----------------------------------------------------------------------------------

\begin{document}

\title{FLasher\\Multi-species, multi-fishery projections with FLR\\Technical maual}

\author[1]{Finlay Scott}
\author[1]{Iago Mosqueira}
\affil[1]{European Commission, Joint Research Centre, IPSC / Maritime Affairs Unit, 21027 Ispra (VA), Italy}
\affil[*]{Corresponding author \href{mailto:finlay.scott@jrc.ec.europa.eu}{finlay.scott@jrc.ec.europa.eu}}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

%<<knitr_opts, echo=FALSE, message=FALSE, warning=FALSE>>=
%library(knitr)
%css = eclipse_theme(43)
%thm = knit_theme$get(css)
%knit_theme$set(thm)
%opts_chunk$set(dev='png', cache=TRUE, fig.align='center', warning=FALSE, message=FALSE, dev="png", dev.args=list(type="cairo"), dpi=96, highlight=TRUE, background='#F2F2F2', fig.lp="fig:", fig.pos="H", width=60)
%@
%
%
%This document is the technical manual for the \pkg{FLasher} package.
%It explains the basic structure of package, with particular emphasis on the C++ code.
%This will allow further expansion of the package.
%
%\pkg{FLasher} is made up of \R code and C++ code. The \R code provides the user front-end and is written using the FLR libraries.
%The C++ code does the heavy lifting and makes up the majority of the source code.
%The C++ side of \pkg{FLasher} uses the classes described in FLRCPP REF and some additional classes and functions that are described here.
%
%The package makes use of the CppAD library for automatic differentation (REF).
%
%
%The document has several examples, so we need to load \pkg{FLasher}.
%
%<<load_libraries, message=FALSE, warning=FALSE>>=
%library(FLasher)
%library(testthat)
%@
%
%\section{The C++ \class{fwdControl} class}
%
%The C++ \class{fwdControl} implements the basic functionality of the FLR \class{fwdControl} class.
%It is a member of the \class{operatingModel} class and controls the projections.
%
%The main members are \code{target}, which is a copy of the \class{data.frame} in the \code{fwdControl@target@element} slot plus some additional columns (see below for details) and
%\code{target\_iters} which holds the information in the \code{fwdControl@target@iters} slot as an \code{Rcpp::NumericVector} and has appropriate accessors.
%
%Intrinsic \code{<as>} and \code{<wrap>} methods have been written to allow \class{fwdControl} objects to be passed to and from \R and C++ easily. However, for the \code{<as>} to work, an additional attribute, \code{FCB}, must be added to the object in R before dispatch, else it will fail (see below).
%
%\subsection{The FCB member}
%
%An important additional member that is not (yet) present in the FLR version of the class is \code{FCB}. This is a 2D matrix that contains a map of a which Fishery and Catch catches which Biol. \code{FCB} has 3 columns, \textit{F}, \textit{C} and \textit{B} for Fishery, Catch and Biol indices respectively. Each row is a mapping of a Fishery / Catch onto a Biol. The indices start at 1 and refer to positions within the \class{FLFisheries}, \class{FLFishery} and \class{fwdBiols} objects respectively (the \class{FLFisheries} object is really just a list of \class{FLFishery} objects, and each \class{FLFishery} object contains a list of \class{FLCatch} objects; the \class{fwdBiols} class is a list of \class{fwdBiol} objects).
%For example, a row with values \code{(1,2,1)} means that the second \class{FLCatch} in the first \class{FLFishery} of the \class{FLFisheries} member catches the first \class{fwdBiol} of the \class{fwdBiols} member.
%
%\code{FCB} is not a slot in the FLR version of \class{fwdControl}. Instead, it must be generated seperately in R as a matrix, and then attached as an attribute called \textit{FCB} to the \code{target} slot before sending it to C++.
%
%There may be a way of generating the \code{FCB} matrix automatically from the information in the \code{fwdControl@target@element} slot.
%
%If you try to pass an \class{fwdControl} from R to C++ without the \code{FCB} attribute it will fail.
%As \code{FCB} is only an attribute of the \class{fwdControl} object and not an actual slot, it is not returned by the intrinsic \code{<wrap>}.
%
%Here we make a simple \class{fwdControl} object in FLR.
%
%<<makeFakefwdControl>>=
%target <- data.frame(year = 1:3,
%                     quantity = 'catch',
%                     value = rep(1000,3))
%fc_in <- fwdControl(target)
%@
%
%We call the test function to see of the \code{<as>} and \code{<wrap>} functions are working correctly.
%
%<<fwdControlAsWrap>>=
%# No FCB attribute so we get an error
%expect_that(test_as_wrap_fwdControl(fc_in), throws_error())
%# Make the FCB matrix (or array)
%FCB <- array(c(1,1,1), dim = c(1,3), dimnames = list(1, c('F','C','B')))
%# Set as attribute of the target slot
%attr(fc_in@target, "FCB") <- FCB
%# Now the as and wrap work OK
%fc_out <- test_as_wrap_fwdControl(fc_in)
%# The returned target slot is OK
%expect_that(fc_in@target@iters, equals(fc_out@target@iters))
%expect_that(fc_in@target@element, equals(fc_out@target@element))
%@
%
%The \code{<wrap>} isn't particularly important because the values in the \class{fwdControl} object don't actually get changed by the \class{operatingModel} class.
%
%\subsection{Target types}
%
%The \code{quantity} column in the \code{element} \class{data.frame} determines the target type.
%In FLR, this column is of type \class{character}. 
%For the C++ side to understand the quantity there is a bit of jiggery pokery.
%An enumerated type, \code{fwdControlTargetType} has been set up at the top of the \code{fwdControl.h} file.
%This lists the target quantity types as they will be referred to in the rest of the C++ code.
%A type of \class{std::map<>} called \code{target\_map\_type} has been set up that maps a character string (a \code{std::string}) to the enumerated type.
%Finally, the class has another member \code{target\_map} which is an instance of the \class{target\_map\_type}.
%\code{target\_map} therefore maps the character string that is passed in from \R to the appopriate target type.
%This might seem fiddly but means that there is no need to use a \code{switch} statement so makes the code cleaner and easier to maintain.
%
%To add a new target quantity to the map there are two things to do:
%\begin{enumerate}
%    \item Add the target to the enumerated type (give it an appropriate name, this will be how it is referred in the rest of the C++ code).
%    \item Add the mapping from the input character string to the enumerated type in the \code{fwdControl::init\_target\_map()} method in the \code{fwdControl.cpp} source code.
%\end{enumerate}
%
%\subsubsection{Abundance targets}
%
%There is a special case for abundance targets, such as SSB or biomass. The values of these quantities are the result of the effort in the previous time step.
%The projection methods need to know which target quantities are affected by effort in what time step.
%The default assumption is that the target value is affected by effort in the current time step.
%For the abundance based target types, an additional member is included in the \class{fwdControl} class to keep track of which target types are actually dependent on effort in the previous year: \code{abundance\_targets}.
%This is simply a vector of the enumerated target type. Any type included in the vector depends on effort in the previous time step.
%The vector is used by the \code{fwdControl::get\_target\_effort\_timestep()} method to determine the effort time step for that target.
%
%The member is populated in the \code{fwdControl.h} file, where the member is declared.
%At the time of writing only SSB and biomass were included.
%To add another type to the vector, simply add it here.
%
%\subsection{Target numbers and simultaneous targets}
%
%As \pkg{FLasher} can have mutiple fisheries and stocks it is possible to have multiple targets in the same time step.
%Each \textit{target} is therefore made up of one or more \textit{simultaneous targets}.
%
%For the projection methods to understand which rows of the \class{element} \class{data.frame} are to be solved simultaneously, it is necessary to include
%a \code{target} column in the \class{data.frame}. This column holds integers of the target numbers. Rows that are \textit{simultaneous targets} of the same \textit{target} have the same integer.
%
%The targets are solved in the order of their target number, not by the time step order. It is therefore important that the order makes chronological sense.
%
%It is also important that simultaneous targets have the same target number.
%
%The target numbers must be contiguous.
%
%\subsection{Other necessary columns}
%
%As well as the columns set up by the \pkg{fwdControl} constructor in FLR, several columns need to be added to the \class{element} \class{data.frame} before sending it to C++. These columns hold information that make the C++ code easier. They can be automatically added on the R side before dispatch to the C++ side so that the user does not have to.
%
%These columns are:
%
%\begin{itemize}
%    \item \code{target}, as mentioned above, this column holds the target number. When running a projection, targets are processed in this order. Simulataneous targets in the same target set should have the same target number.
%    \item \code{timestep}, the timestep of the target. The control object does not hold any information on the number of seasons in the operating model so cannot just use the existing \code{year} and \code{season} columns to calculate the time step of the target. It must therefore be included as a separate column.
%    \item \code{fishery}, \code{catch} and \code{biol} columns. These specify which fishery, catch and biol the target applies to. This should be specified by the user when there are more than 1 fishery etc. Else it can be generated automatically. 
%\end{itemize}
%
%
%\subsection{Examples}
%
%Here we demonstrate the methods of the \class{fwdControl} class.
%First we make an example object. We assume that the operating model contains two fisheries, each with one catch, both of which catch the same stock.
%
%% Fix this example as the min target is actually a new target
%
%<<makeFakefwdControl2>>=
%# Set up data.frames of the two targets
%# Both catches have a target catch from biol 1
%# Also include a minimum constraint on the biomass - must be treated as a new target
%target <- data.frame(year = c(2000, 2000, 2001),
%                     quantity = c('catch', 'catch', 'biomass'),
%                     value = c(1000, 1000, NA),
%                     min = c(NA, NA, 10000),
%                     fishery = c(1,2,NA),
%                     catch = c(1,1,NA),
%                     biol = c(1,1,1),
%                     # Include target and timestep column - user should not have to do this
%                     timestep = c(1,1,2),
%                     target = c(1,1,2)
%                     )
%
%fc_in <- fwdControl(target)
%# Set up the iters array to have 5 iters
%target_iters <- array(NA, dim=c(nrow(target),3,5), dimnames=list(target_no=1:nrow(target),
%                                                                 c("min","value","max"),
%                                                                 iter=1:5))
%target_iters[1:2,'value',] <- rnorm(10,mean=1000,sd=1)
%target_iters[3,'min',] <- rnorm(5,mean=10000,sd=10)
%fc_in@target@iters <- target_iters
%# Set FCB
%FCB <- array(c(1,1,1), dim = c(1,3), dimnames = list(1, c('F','C','B')))
%attr(fc_in@target, "FCB") <- FCB
%fc_in
%@
%
%Now test some methods
%
%<<testfwdControlMethods>>=
%# How many timesteps in the control
%test_fwdControl_get_ntimestep(fc_in)
%# How many targets (sets of simultaneous targets)
%test_fwdControl_get_ntarget(fc_in)
%# How many iterations in the iters slot
%test_fwdControl_get_niter(fc_in)
%# How many simultaneous targets in a target set
%test_fwdControl_get_nsim_target(fc_in, 1)
%test_fwdControl_get_nsim_target(fc_in, 2)
%# Get the target rows of a particular target (index starts at 0)
%test_fwdControl_get_target_rows(fc_in, 1)
%test_fwdControl_get_target_rows(fc_in, 2)
%# Get the row number of simultaneous target in a target set
%test_fwdControl_get_target_row(fc_in, 1, 1)
%test_fwdControl_get_target_row(fc_in, 2, 1)
%# Pull out all targets from an integer column
%test_fwdControl_get_target_int_col(fc_in, 1, 'year')
%test_fwdControl_get_target_int_col(fc_in, 2, 'biol')
%# Pull out all targets from a numeric column - why do we have this?
%test_fwdControl_get_target_int_col(fc_in, 1, 'value')
%test_fwdControl_get_target_int_col(fc_in, 2, 'value')
%# Get target values from iters slot - 1 is min, 2 is value, 3 is max
%# All simultaneous targets of that target set
%test_fwdControl_get_target_value(fc_in, 1, 2) # value of target 1
%test_fwdControl_get_target_value(fc_in, 2, 1) # min of target 2
%# Just one simultaneous target
%test_fwdControl_get_target_value2(fc_in, 1, 1, 2) # value of sim target 1 from arget 1
%test_fwdControl_get_target_value2(fc_in, 2, 1, 1) # min of sim target 3 from target 2
%# Get the quantity of the type of sim target in target
%test_fwdControl_get_target_quantity(fc_in, 1, 1)
%# Get timestep of effort that affects sim target
%test_fwdControl_get_target_effort_timestep(fc_in, 1, 1) # catch in timestep 1
%test_fwdControl_get_target_effort_timestep(fc_in, 2, 1) # biomass in timestep 2
%@
%
%
%\section{The \class{operatingModel} class}
%
%The C++ class responsible for running the projections is \class{operatingModel}. The source code can be found in src/operatingModel.cpp
%Many of the methods of the \pkg{operatingModel} class are directly callable from \R though this functionality will really only be useful for testing and demonstrating purposes. 
%
%\subsection{The basic process}
%
%The basic process for using the \class{operatingModel} is:
%
%\begin{itemize}
%    \item Create the necessary \class{FLFisheries}, \class{fwdBiols}, stock recruitment and \class{fwdControl} objects in FLR.
%    \item Pass the objects into C++ and create the \class{operatingModel} class.
%    \item Call the \code{run()} method.
%    \item Return the \pkg{operatingModel} object to R as a list.
%\end{itemize}
%
%
%\subsection{Creating an \class{operatingModel}}
%
%The C++ objects we need to create an \pkg{operatingModel} in C++ are:
%
%\begin{itemize}
%    \item An \class{FLFisheries} object;
%    \item An \class{fwdBiols} object;
%    \item An \class{fwdControl} object;
%\end{itemize}
%
%The \class{FLFisheries} and \class{fwdControl} objects can be passed in directly from R using the intrinsic \code{<as>} methods.
%The \class{fwdBiols} object is more complicated. This needs to be constructed in C++ first.
%It can be constructed from a list of \class{FLBiol}s and SRR components (see FLRCPP REF).
%
%
%\subsection{Inside \code{run()}}
%
%The input to a fishery is the fishing effort. This is the variable that we control to hit the desired targets in a particular time step.
%Inside the \code{run()} method, we really find the effort multiplier in that time step, and then apply it.
%
%As mentioned above, as we can have mutiple fisheries and stocks it is possible to have multiple targets in the same time step. We then need to find the effort multiplier for each fishery to hit all targets (if possible).
%Each \textit{target} is therefore made up of one or more \textit{simultaneous targets}.
%
%Inside \code{run()}, each target (set of simultaneous targets) is processed in turn.
%Before the first target is processed, the biology in the first target time step is updated, using effort in the previous time step, i.e. the survivors from the last time step of fishing.
%This ensures that we can calculate landings and discards using the effort in the target time step and the abundances.
%It means that we ensure that the biological abundances in the first projection year are consistent with fishing effort in the previous year (and hope that landings and discards are also consistent).
%The number of targets is taken from the \code{get\_ntarget()} method. This accesses the \code(target) column in the control data.frame and relies on the target number staring at 1 and being contiguous.
%
%The basic sequence for each target is:
%
%\begin{itemize}
%    \item Get the number of simultaneous targets inside that target (using the \code{get\_nsim\_target()} method).
%    \item Get the timestep that we need to adjust effort in that will allow us to hit the target (using the \code{get\_target\_effort\_timestep()} method which accounts for the biomass being the result of effort in the previous timestep).
%    \item Get the desired target values, i.e. the values of the simultaneous targets we want to hit (using the \code{get\_target\_value() method}).
%    \item Set the independent variable (effort multiplier) the for the automatic differentiation recording.
%    \item Update the effort in each fishery by the effort multiplier.
%    \item Project the biology in the operating model in the target timestep (using the \code{project\_biols()} method). This updates the biology in the timestep, based on the effort in the previous timestep.
%    \item Project the fisheries in the operating model in the target timestep (using the \code{project\_fisheries()} method). This updates the landings and discards in each \class{FLCatch} based on the effort and biology in the timestep.
%    \item Get the current values of the simultaneous targets, i.e. the values that resulted from using that effort multiplier (using the \code{get\_target\_value\_hat()} method).
%    \item Calculate the error which is the difference between the target values we wanted and the the values we actually have. The length of the error variable is the same as the number of simultaneous targets.
%    \item Store the error as the dependent variable for the automatic differentiation recording.
%    \item Find the effort multipliers needed to reduce the errors to 0 (using the \code{newton\_raphson()} method).
%    \item Update the effort of each fishery with the new effort multipliers.
%    \item Project the operating model in that timestep again, this time with the new effort values.
%    \item Go to the next target.
%\end{itemize}
%
%We take a look at some of these steps in more detail.
%
%%\subsubsection{Getting the desired target values}
%%
%%\subsubsection{Getting the current target values}
%
%\subsection{The future}
%
%Adding target types
%
%Parallel
%
%\section{The Newton Raphson solver}

\end{document}

