---
title: "FLasher vs FLash"
author: "Finlay Scott and Iago Mosqueira"
date: "28 April, 2016"
output: pdf_document 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This document compares the output of **FLash** and **FLasher** FLR packages for a series of different projections.
The aim is to identify any differences in their output.

The projections are based on a single fleet fishing a single fish stock (this is what **FLash** does).

## Basic setup

Load the libraries.

```{r libraries, results="hide"}
library(FLasher)
library(FLash)
library(FLAssess)
```

The projections are based on the *ple4* data set.

```{r ple4}
data(ple4)
```

We fit a simple stock-recruitment relationship (SRR) to use in the projections.

```{r bevholt, results="hide"}
model <- "bevholt"
ple4.sr <- fmle(as.FLSR(ple4, model=model))
```

**FLash** uses *FLStock* objects for the projections. **FLasher** uses *FLFisheries* and *FLBiols* objects. However, the projection method for **FLasher** is able to take and return an *FLStock* making it easy to run comparisons between the packages.

## Simple projections

Here we run very simple projections based on catch, landings and discards targets.
The projected objects only have 1 iteration and there is no stochasticity.

We set up a projection three years into the future:

```{r landings_target}
ple4_stf <- stf(ple4, 3)
```

### Landings target

#### Running the projections

In the first example we set up a 3 year projection from 2009 with a landings target.

```{r landings_target}
landings_target <- seq(from=48000, to=45000, length=3)
```

The **FLash** control object is set up as:

```{r simple_flash_landings_control}
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "landings",
			  val = landings_target)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
```

The **FLasher** control object is also set up. This needs slightly more work at the moment.

```{r flasher_trgt}
flasher_ctrl_target <- data.frame(year = 2009:2011, season = 1,
                        quant = "landings", order = 1:3, value = landings_target,
                        fishery = 1, catch = 1, biol = NA)
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target)
```

We run the **FLash** projection using:

```{r simple_landings_fwd, results="hide"}
flash_stf <- FLash::fwd(ple4_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

We run the **FLasher** projection using:

```{r simple_landings_FLasher_run, results="hide", message=FALSE}
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

The message about finding more than one class of *fwdControl* comes from having loaded both **FLasher** and **FLash** and can be ignored.


#### Comparing the outputs

Have the targets been hit in the projection years 2009 to 2011?

```{r compl1}
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```

Is the catch information (landings and discards by age) the same? We look at the differences in the projection years.

```{r compc1}
landings.n(flash_stf)[,ac(2009:2011)] -
    landings.n(flasher_stf)[,ac(2009:2011)]
discards.n(flash_stf)[,ac(2009:2011)] -
    discards.n(flasher_stf)[,ac(2009:2011)]
```

When **FLash** is projecting it is attempting to find the scalar multiplier for each target that is applied to the existing values for fishing mortality (F).
**FLasher** finds the level of effort necessary to hit the targets and F is calculated internally base on the effort and stock catchability and selectivity.
The *fwder()* functions calculates the final F based on the estimated effort values. These should be the same as the **Flash** values.

```{r compf1}
harvest(flasher_stf)[,ac(2009:2011)] - harvest(flash_stf)[,ac(2009:2011)]
```

Finally, we check the stock abundances.
The impact of the landings target is not realised in the stock abundance until the following year. However, both **FLash** and **FLasher** update the stock abundance in the
first projection year based on the F in the previous year. 

```{r }
stock.n(flash_stf)[,ac(2009:2011)] - stock.n(flasher_stf)[,ac(2009:2011)]
```

#### Summarising the comparison

```{r compfunc, echo=FALSE}
flash_flasher_comp <- function(flash, flasher, proj_years){
    # Compare landings.n and discards
    landings_diff <- mean(landings.n(flash)[,ac(proj_years)] -
        landings.n(flasher)[,ac(proj_years)])
    discards_diff <- mean(discards.n(flash)[,ac(proj_years)] -
        discards.n(flasher)[,ac(proj_years)])
    # F
    f_diff <- mean((harvest(flasher) - harvest(flash))[,ac(proj_years)])
    # N 
    n_diff <- mean(stock.n(flash)[,ac(proj_years)] - stock.n(flasher)[,ac(proj_years)])
    out <- c(Landings = landings_diff, Discards = discards_diff, F = f_diff, N = n_diff)
    return(out)
}
```

To summarise the differences between the results from **FLasher** and **FLash** a function has been written that returns the mean differences between the:

* landings numbers at age
* discards numbers at age
* F at age
* stock abundance at age (in projection years)

```{r comp1}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

Using this we can run further tests on **Flasher** and **Flash** and compare the results

### Mixing landings, discards and catch targets

```{r, results='hide', message=FALSE}
target_values <- seq(from=10000, to=16000, length=3)
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = c("landings","discards","catch"),
			  val = target_values)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011, season = 1,
                        quant = c("landings","discards","catch"),
                        order = 1:3, value = target_values,
                        fishery = 1, catch = 1, biol = NA)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit?

```{r }
target_values
c(landings(flash_stf)[,ac(2009)],
    discards(flash_stf)[,ac(2010)],
    catch(flash_stf)[,ac(2011)])
c(landings(flasher_stf)[,ac(2009)],
    discards(flasher_stf)[,ac(2010)],
    catch(flasher_stf)[,ac(2011)])
```

We summarise the differences between the two packages:

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### F target

Here we set an F target for each year of the projection.

```{r }
target_fbar <- 0.3

flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "f",
			  val = target_fbar)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011, season = 1,
                        quant = "f",
                        order = 1:3, value = target_fbar,
                        fishery = 1, catch = 1, biol = 1)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have we hit the target?

```{r }
fbar(flash_stf)[,ac(2009:2011)]
fbar(flasher_stf)[,ac(2009:2011)]
```

The differences:

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### SSB target

SSB measures the mass of the mature stock at the time of spawning.
With **FLash** the timing of the SSB target depends on the *harvest.spwn* slot in the *FLStock* object.

If spawning occurs during or after the fishing period, the SSB target can be hit in that year.
However, if spawning occurs before fishing starts then changing the fishing pressure will not affect the SSB in that year and so it is not possible to hit the target in that year. Instead the target is hit in the following year.

In this first example, the *harvest.spwn* and *m.spwn* slots have a value of 0, i.e. spawning happens before any natural mortality or fishing takes place.


```{r }
target_ssb <- c(180000, 150000, 150000)
ple4_stf@harvest.spwn[] <- 0
ple4_stf@m.spwn[] <- 0

flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "ssb",
			  val = target_ssb)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))
```
Here, the SSB target is hit in the following year as it is not possible to hit it in the current year.
The SSB in the first forecast year (2009) is based on the exising F in the previous year (2008).

```{r }
ssb(flash_stf)[,ac(2009:2011)]
fbar(flash_stf)[,ac(2009:2011)]
```

**FLasher** has the same behaviour.

```{r }
flasher_ctrl_target <- data.frame(year = 2009:2011, season = 1,
                        quant = "ssb",
                        order = 1:3, value = target_ssb,
                        fishery = NA, catch = NA, biol = 1)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

PROBLEM WITH TIMING - IN EVAL_OM DON'T JUST CRASH - RETIRE GRACEFULLY

If we set the *harvest.spwn* slot to 0.25 (implying a quarter of the fishing mortality in that year happens before spawning) and the *m.spwn* slot to 0.5 (implying that spawning happens half way through the year as natural mortality is continuous all year) then we can hit the SSB target in the required year.

```{r }
ple4_stf@harvest.spwn[] <- 0.25
ple4_stf@m.spwn[] <- 0.5
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))
ssb(flash_stf)[,ac(2009:2011)]
fbar(flash_stf)[,ac(2009:2011)]
```

**FLasher** has the same behaviour.

```{r }
flasher_ctrl_target <- data.frame(year = 2009:2011, season = 1,
                        quant = "ssb",
                        order = 1:3, value = target_ssb,
                        fishery = NA, catch = NA, biol = 1)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
ssb(flasher_stf)[,ac(2009:2011)]
fbar(flasher_stf)[,ac(2009:2011)]
```




## Min and max targets

Here we project with a landings target but with a maximum limit on discards.
We still use a single iteration without stochasticity.

The same target and maximum limit is applied in all years.

```{r }
landings_target <- 90000
discards_max <- 40000
```

The **FLash** projection:

```{r }
flash_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
			  quantity = rep(c("landings", "discards"), 3),
			  val = rep(c(landings_target, NA), 3),
			  max = rep(c(NA, discards_max), 3))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results="hide", message=FALSE}
flasher_ctrl_target <- data.frame(year = rep(2009:2011, each=2), season = 1,
                        quant = rep(c("landings", "discards"), 3), order = 1:6,
                        value = rep(c(landings_target, NA), 3),
                        max = rep(c(NA, discards_max), 3),
                        fishery = 1, catch = 1, biol = NA)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit and the limits respected?

```{r}
landings(flasher_stf)[,ac(2009:2011)]
landings(flash_stf)[,ac(2009:2011)]
discards(flasher_stf)[,ac(2009:2011)]
discards(flash_stf)[,ac(2009:2011)]
```

Are the **FLash** and **FLasher** objects the same?

```{r}
flash_flasher_comp(flash_ple4, flasher_ple4, 1958:1962)
```

## Relative targets

In this example we set the catches to be relative to the previous year.
The relative target is 0.9.

The **FLash** projection:

```{r}
flash_ctrl_target <- data.frame(year = 1958:1962,
			  quantity = "catch",
			  val = 0.9, rel.year = 1957:1961)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_ple4 <- FLash:::fwd(ple4, flash_ctrl, ple4.sr)

```

The **FLasher** projection:

```{r, results="hide"}
flasher_ctrl_target <- data.frame(year = 2:6, season = 1, timestep = 2:6,
                        quantity = "catch", target = 1:15,
                        value = 0.9,
                        fishery = 1, catch = 1, biol = NA, 
                        relFishery = 1, relCatch = 1, relBiol = NA,
                        relYear = 1:5, relSeason = 1)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
attr(flasher_ctrl@target, "FCB") <- FCB
flasher_ple4 <- test_operatingModel_run(om$fisheries, om$biol, flasher_ctrl, 1, 1e9)
```
Are the relative catches correct?

```{r}
catch(flash_ple4)[,ac(1958:1962)] /
    catch(flash_ple4)[,ac(1957:1961)]
catch(flasher_ple4[["fisheries"]][[1]][[1]])[,ac(1958:1962)] /
    catch(flasher_ple4[["fisheries"]][[1]][[1]])[,ac(1957:1961)]
```

Are the **FLash** and **FLasher** objects the same?

```{r}
flash_flasher_comp(flash_ple4, flasher_ple4, 1958:1962)
```


## Relative targets with limits

Here we increase catches by a relative amount each year, but set a maximum discards limit.

The **FLash** projection:

```{r}
discards_max <- 10000

flash_ctrl_target <- data.frame(year = rep(1958:1962, each=2),
			  quantity = rep(c("catch", "discards"), 5),
			  val = rep(c(0.9, NA), 5),
			  max = rep(c(NA, discards_max), 5),
            rel.year = c(1957, NA, 1958, NA, 1959, NA, 1960, NA, 1961, NA))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_ple4 <- FLash:::fwd(ple4, flash_ctrl, ple4.sr)
```

The **FLasher** projection (control object is looking quite horrible):

```{r, results='hide'}
flasher_ctrl_target <- data.frame(year = rep(2:6, each=2), season = 1,
                        timestep = rep(2:6, each=2),
                        quantity = rep(c("catch", "discards"), 5), target = 1:10,
                        value = rep(c(0.9, NA), 5),
                        max = rep(c(NA, discards_max), 5),
                        fishery = 1, catch = 1, biol = NA, 
                        relFishery = rep(c(1,NA),5),
                        relCatch = rep(c(1,NA),5),
                        relBiol = NA,
                        relYear = c(1,NA,2,NA,3,NA,4,NA,5,NA),
                        relSeason = rep(c(1,NA),5))
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
attr(flasher_ctrl@target, "FCB") <- FCB
flasher_ple4 <- test_operatingModel_run(om$fisheries, om$biol, flasher_ctrl, 1, 1e9)
```

Relative targets have been hit, respecting the limits.

```{r}
discards(flash_ple4)[,ac(1958:1962)]
catch(flash_ple4)[,ac(1958:1962)] /
    catch(flash_ple4)[,ac(1957:1961)]

discards(flasher_ple4[["fisheries"]][[1]][[1]])[,ac(1958:1962)]
catch(flasher_ple4[["fisheries"]][[1]][[1]])[,ac(1958:1962)] /
    catch(flasher_ple4[["fisheries"]][[1]][[1]])[,ac(1957:1961)]
```

And the objects are the same.

```{r}
flash_flasher_comp(flash_ple4, flasher_ple4, 1958:1962)
```

## Projections with stochasticity

Here we run projections but this time with multiple iterations.

### Iterations in the objects

First we expand the objects to have multiple iterations.
```{r }
niters <- 100

ple4p <- propagate(ple4, niters)
omp <- flasher_annual_stock_prep(stk = ple4, srr_model = "bevholt",
    srr_params = params(ple4.sr), srr_residuals = res1,
    srr_residuals_mult = TRUE, niters=niters)
```

Then we add random noise to the stock abundances in the *FLStock* and the *FLBiol* but make sure that the abundances are the same.

```{r }
new_n <- n(omp[["biol"]][[1]][["biol"]])
new_n <- new_n * rnorm(prod(dim(new_n)), mean=1, sd=0.1)
n(omp[["biol"]][[1]][["biol"]]) <- new_n
stock.n(ple4p) <- new_n
```

We project for 3 years with a landings target and with iterations in the target values.

```{r, results="hide"}
target_values <- abs(rnorm(niters * 3, mean=10000, sd=100))

flash_ctrl_target <- data.frame(year = 1959:1961,
			  quantity = c("landings","landings","landings"),
			  val = target_values[1:3])
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
# Hack the target array
flash_ctrl@trgtArray <- array(NA, dim = c(3, 3, niters),
    dimnames=list(1:3, c("min","val","max"), iter=1:niters))
flash_ctrl@trgtArray[,"val",] <- target_values
flash_ple4 <- FLash:::fwd(ple4p, flash_ctrl, ple4.sr)

flasher_ctrl_target <- data.frame(year = 3:5, season = 1, timestep = 3:5,
                        quantity = c("landings","landings","landings"),
                        target = 1:3, value = target_values[1:3],
                        fishery = 1, catch = 1, biol = NA, 
                        relFishery = NA, relCatch = NA, relBiol = NA,
                        relYear = NA, relSeason = NA
                        )
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target, iters=niters)
flasher_ctrl@target@iters[,"value",] <- target_values
attr(flasher_ctrl@target, "FCB") <- FCB
flasher_ple4 <- test_operatingModel_run(omp$fisheries, omp$biol, flasher_ctrl, 1, 1e9)
```

Did we hit the targets?

```{r }
FLQuant(target_values, dimnames=list(year=1959:1961, iter=1:niters))
landings(flash_ple4)[,ac(1959:1961)]
landings(flasher_ple4[["fisheries"]][[1]])[,ac(1959:1961)]
```

Are the **FLasher** and **FLash** results comparable?

```{r }
flash_flasher_comp(flash_ple4, flasher_ple4, 1959:1961)
```

### Stochasticity in the SRR through residuals

We run the same projection as above but now also including stochastic multiplicative residuals in the SRR.

We generate the multiplicative residuals by sampling with replacement:

```{r }
resp <- propagate(res, niters)
resp[] <- sample(exp(c(res)), prod(dim(resp)), replace=TRUE)
```

To project with **FLash** we pass in the subset of the residuals that contains the years of the projection we are performing.

```{r }
flash_ple4_res <- FLash:::fwd(ple4p, flash_ctrl, ple4.sr,
    sr.residuals = resp[,ac(1959:1962)], sr.residuals.mult=TRUE)
```

For **FLasher** we pass in an 
For **FLasher** we set the residuals as part of the biols list.
The residuals are an *FLQuant* with the same years as the other objects but even though only a subset of them are used internally (this interface will be improved in the future).

```{r, results="hide"}
omp[["biol"]][[1]][["srr_residuals"]] <- resp
flasher_ple4_res <- test_operatingModel_run(omp$fisheries, omp$biol, flasher_ctrl, 1, 1e9)
```

Is the predicted recruitment correct?
Here we calculate by hand by using the SSB generated by **FLash** and applying the residuals.
**FLasher** gives the correct results. **FLash** is different in the final year (see above). 

```{r }
predict(ple4.sr, ssb=ssb(flash_ple4_res)[,ac(1959:1961)]) * resp[,ac(1960:1962)]
rec(flash_ple4_res)[,ac(1960:1962)]
rec(flasher_ple4_res[["biols"]][[1]])[,ac(1960:1962)]
```
And the objects are the same (apart from recritment in the final year).

```{r }
flash_flasher_comp(flash_ple4, flasher_ple4, 1959:1961)
```

### Stochasticity in the SRR parameters

**FLasher** and **FLash** are also capabale of adding stochasticity through the SRR parameters.

First we generate some variance in the SRR parameters.
```{r}
paramsp <- propagate(params(ple4.sr), niters)
paramsp[] <- abs(rnorm(niters*2, c(params(ple4.sr)), 10))
ple4.srp <- ple4.sr
params(ple4.srp) <- paramsp
```

Then we project **FLash** without residuals.

```{r}
flash_ple4_res <- FLash:::fwd(ple4p, flash_ctrl, ple4.srp)
```

For **FLasher** we need to set the residuals to be 1 (effectively no residuals) and set the parameters of the biols list.

```{r, results="hide"}
omp[["biol"]][[1]][["srr_residuals"]][] <- 1
omp[["biol"]][[1]][["srr_params"]] <- as(params(ple4.srp), "FLQuant")
flasher_ple4_res <- test_operatingModel_run(omp$fisheries, omp$biol, flasher_ctrl, 1, 1e9)
```

Again, **FLasher** and **FLash** produce the same results (except the final year for **FLash** is not right).
The results are checked by comparing to the predicted recruitment using the predicted SSB from **FLash**.

```{r}
predict(ple4.srp, ssb=ssb(flash_ple4_res)[,ac(1958:1961)])
rec(flash_ple4_res)[,ac(1959:1962)]
rec(flasher_ple4_res[["biols"]][[1]])[,ac(1959:1962)]
```

## The 'Wedding Cake' example


## Other stuff 
NOTES

In **FLasher** The F calculation in **FLasher** is:

$F = \alpha B^{\beta} S E$

Where $\alpha$ and $\beta$ are the catchability parameters, *B* is the biomass of the stock being fished, *S* is the age structured selectivity and *E* is the fishing effort. 
Here, $\beta$ has been set to 0 so that F is linearly related to effort.
The selectivity and catchability parameters in the *FLFisheries* have been set up so that an effort of 1 results in the current fishing mortality values in *ple4*.
