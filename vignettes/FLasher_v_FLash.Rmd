---
title: "Comparing results of Flash and FLasher"
author: Iago Mosqueira & Finlay Scott - European Commission Joint Research Center
date: "`r format(as.Date(system('git log -1 --format=%ci', intern=TRUE)), '%B %Y')`"
tags: [FLR, forecast, MSE]
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Comparing results of Flash and FLasher}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# FLasher vs FLash

Finlay Scott and Iago Mosqueira

## Introduction

This document compares the output of the the **FLash** and **FLasher** FLR packages for a series of different projections.
The aim is to identify any differences in their output.

The projections are based on a single fleet fishing a single fish stock (this is what **FLash** does) using an *FLStock* object.

## Basic setup

Load the libraries.

```{r libraries, results="hide"}
library(FLasher)
library(FLash)
library(FLAssess)
```

The outputs of **FLash** and **FLasher** will be compared using the following function.
This compares the predicted landings, discards, F and stock abundance.

```{r compfunc, echo=FALSE}
flash_flasher_comp <- function(flash, flasher, proj_years){
    # Compare landings.n, discards.n and catch.n
    landingsn_diff <- mean(landings.n(flash)[,ac(proj_years)] -
        landings.n(flasher)[,ac(proj_years)])
    discardsn_diff <- mean(discards.n(flash)[,ac(proj_years)] -
        discards.n(flasher)[,ac(proj_years)])
    catchn_diff <- mean(catch.n(flash)[,ac(proj_years)] -
        catch.n(flasher)[,ac(proj_years)])
    # Compare landings.wt, discards.wt and catch.wt
    landingswt_diff <- mean(landings.wt(flash)[,ac(proj_years)] -
        landings.wt(flasher)[,ac(proj_years)])
    discardswt_diff <- mean(discards.wt(flash)[,ac(proj_years)] -
        discards.wt(flasher)[,ac(proj_years)])
    catchwt_diff <- mean(catch.wt(flash)[,ac(proj_years)] -
        catch.wt(flasher)[,ac(proj_years)])
    # Compare landings, discards and catch
    landings_diff <- mean(landings(flash)[,ac(proj_years)] -
        landings(flasher)[,ac(proj_years)])
    discards_diff <- mean(discards(flash)[,ac(proj_years)] -
        discards(flasher)[,ac(proj_years)])
    catch_diff <- mean(catch(flash)[,ac(proj_years)] -
        catch(flasher)[,ac(proj_years)])
    # F
    f_diff <- mean((harvest(flasher) - harvest(flash))[,ac(proj_years)])
    # N 
    n_diff <- mean(stock.n(flash)[,ac(proj_years)] - stock.n(flasher)[,ac(proj_years)])
    out <- signif(c(CatchN = catchn_diff, LandingsN = landingsn_diff, DiscardsN = discardsn_diff,
            CatchWt = catchwt_diff, LandingsWt = landingswt_diff, DiscardsWt = discardswt_diff,
            Catch = catch_diff, Landings = landings_diff, Discards = discards_diff,
            F = f_diff, N = n_diff),3)
    return(out)
}
```

The projections are based on the *ple4* data set.

```{r ple4}
data(ple4)
```

We fit a simple stock-recruitment relationship (SRR) to use in the projections.

```{r bevholt, results="hide"}
model <- "bevholt"
ple4.sr <- fmle(as.FLSR(ple4, model=model))
```

**FLash** uses *FLStock* objects for the projections. **FLasher** uses *FLFisheries* and *FLBiols* objects. However, the projection method for **FLasher** is able to take and return an *FLStock* making it easy to run comparisons between the packages.

We set up a projection three years into the future:

```{r }
ple4_stf <- stf(ple4, 3)
```

## A first projection and known differences between **FLash** and **FLasher**

Here we run simple catch based projection and compare the results in detail.

```{r }
catch_target <- 90000
```

The **FLash** control object is set up as:

```{r simple_flash_catch_control}
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "catch",
			  val = catch_target)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
```

The **FLasher** control object is also set up. Note that some of the arguments have different names.

```{r flasher_trgt}
flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "catch", order = 1:3,
                        value = catch_target)
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target)
```

The messages about finding more than one class of *fwdControl* comes from having loaded both **FLasher** and **FLash** and can be ignored.

We run the **FLash** projection using:

```{r simple_catch_fwd, results="hide"}
flash_stf <- FLash::fwd(ple4_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

We run the **FLasher** projection using:

```{r simple_catch_FLasher_run, results="hide", message=FALSE}
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit in the projection years 2009 to 2011?

```{r}
catch_target
catch(flash_stf)  [,ac(2009:2011)]
catch(flasher_stf)[,ac(2009:2011)]
```

Both **FLasher** and **FLash** have hit the target.
Are the returned *FLStock* objects from **FLasher** and **FLash** the same?

One important difference between **FLasher** and **FLash** is how the mean catch weights are treated.
With **FLash** the mean catch weights are fixed when the projection is set up (here, using *stf()*).
With **FLasher** the mean catch weights are not fixed but are calculated during the projection from the landings and discards numbers and weights. As F changes, the landings and discards numbers change. This then changes mean catch weights as well as the catch numbers. The mean catch weights specified when the projection is set up is simply ignored.

This means that, depending on the target type, the mean catch weights in the returned *FLStock* objects from **FLasher** and **FLash** may not be the same. This is of particular importance when using a catch target.

In this example the mean catch weights are slightly different (only the first year of the projection is shown):

```{r}
cbind(catch.wt(flash_stf)  [,ac(2009)], catch.wt(flasher_stf)[,ac(2009)])
```

We saw above that both packages hit the desired total catch target. As the mean catch weights are different, this means that the projected catch numbers are different.

```{r}
cbind(catch.n(flash_stf)  [,ac(2009)], catch.n(flasher_stf)[,ac(2009)])
```

The projected landings and discards numbers and totals are also different (the weights are fixed in both **FLash** and **FLasher**).

```{r}
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
discards(flash_stf)  [,ac(2009:2011)]
discards(flasher_stf)[,ac(2009:2011)]
```

As we have different catch numbers but the same starting stock abundances (in 2008), the projected fishing mortality and stock abundances are also different.

```{r}
fbar(flash_stf)  [,ac(2009:2011)]
fbar(flasher_stf)[,ac(2009:2011)]
stock(flash_stf)  [,ac(2009:2011)]
stock(flasher_stf)[,ac(2009:2011)]
```

However, the projected discard ratios from the two packages are the same:

```{r}
df_flash <- discards.n(flash_stf) / (discards.n(flash_stf) + landings.n(flash_stf))
df_flasher <- discards.n(flasher_stf) / (discards.n(flasher_stf) + landings.n(flasher_stf))
df_flash[,ac(2009:2011)]
df_flasher[,ac(2009:2011)]
```

And this discard ratio has been applied correctly (just checking...):

```{r}
(catch.n(flash_stf) * df_flash)[,ac(2009)] - discards.n(flash_stf)[,ac(2009)]
(catch.n(flasher_stf) * df_flasher)[,ac(2009)] - discards.n(flasher_stf)[,ac(2009)]
```

In this example, we have seen that **FLash** and **FLasher** both hit the target but they have different projection results for other metrics.
As mentioned above, this difference is driven by **FLash** having fixed mean catch weights.
The problem with fixed mean catch weights is that it breaks the internal consistency of the *FLStock* object.
For example, if we sum the projected total landings and discards we would expect to get the projected total catches.
This happens with **FLasher** but is not the case with **FLash**.

```{r}
# Flash
(landings(flash_stf) + discards(flash_stf))[,ac(2009:2011)]
catch(flash_stf)[,ac(2009:2011)]
# FLasher
(landings(flasher_stf) + discards(flasher_stf))[,ac(2009:2011)]
catch(flasher_stf)[,ac(2009:2011)]
```
Here we calculate the mean catch weights from both packages using the projected landings and discards numbers and (fixed) weights.

```{r}
flash_cw <- (((landings.n(flash_stf) * landings.wt(flash_stf)) + (discards.n(flash_stf) * discards.wt(flash_stf))) / (landings.n(flash_stf) + discards.n(flash_stf)))
flash_cw[,ac(2009:2011)]
catch.wt(flash_stf)[,ac(2009:2011)]

flasher_cw <- (((landings.n(flasher_stf) * landings.wt(flasher_stf)) + (discards.n(flasher_stf) * discards.wt(flasher_stf))) / (landings.n(flasher_stf) + discards.n(flasher_stf)))
flasher_cw[,ac(2009:2011)]
catch.wt(flasher_stf)[,ac(2009:2011)]
```
The above demonstrates that the fixed mean catch weights stored in the results from **FLash** do not reflect the mean catch weights when calculated using the landings and discards (the 'true' mean catch weight). This means that the projections are not internally consistent.
The historical object (1957 to 2008) also has this problem. This reflects the inconsistency in the available data and is an accepted issue.
However, it can be argued that the projections should not be inconsistent.
In this respect projections with **FLasher** can be considered to be an improvement on the projections with **FLash**.

Using the comparison function defined above gives:

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```
We can see that the mean landings and discards weights and total catch are the same, but all other metrics have some differences.

These differences depend on the target type. When using target types other than catch we should not see them, apart from in the total catch and mean catch weights.
For this reason we avoid using a catch target for the remainder of this document were possible.

## Simple projections

Here we run very simple projections based on different target types.
The projected objects only have 1 iteration and there is no stochasticity.

### Landings target

```{r }
landings_target <- seq(from=48000, to=45000, length=3)

flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "landings",
			  val = landings_target)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
flash_stf <- FLash::fwd(ple4_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "landings", order = 1:3,
                        value = landings_target)
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit in the projection years 2009 to 2011?

```{r compl1}
landings_target
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```

We can compare the returned *FLStock* objects using the function defined above.

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

In this example we can see that all metrics, apart from mean catch weights and the total catches, are the same. As mentioned above these differences are driven by the catch weights being fixed in the **FLash** projection (as catch is not a target type here it does not impact on the other metrics).

This is another illustration of the lack of internal consistency in the **FLash** projection.
In this example, the projected total catches do not equal the sum of the projected landings and discards.
It would of course be possible to correct the mean catch weights and total catch after the projection, so long as total catch was not the target type.

### Mixing landings and discards targets

In this example we set a mix of landings and discards targets in the 3 projection years.
It's a pretty useless example but serves to illustrate that **FLash** and **FLasher** produce the same output (apart from the differences noted above).

```{r, results='hide', message=FALSE}
target_values <- seq(from=10000, to=16000, length=3)
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = c("landings","landings","discards"),
			  val = target_values)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = c("landings","landings","discards"),
                        order = 1:3, value = target_values)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit?

```{r }
target_values
# FLash
c(landings(flash_stf)[,ac(2009)], landings(flash_stf)[,ac(2010)], discards(flash_stf)[,ac(2011)])
# FLasher
c(landings(flasher_stf)[,ac(2009)], landings(flasher_stf)[,ac(2010)], discards(flasher_stf)[,ac(2011)])
```

We summarise the differences between the two packages:

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

As above, all metrics apart from total catch and mean catch weight are the same.

### F target

Here we set an F target for each year of the projection.

```{r }
target_fbar <- c(0.3,0.2,0.1)

flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "f",
			  val = target_fbar)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "f",
                        order = 1:3, value = target_fbar)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have we hit the target?

```{r }
target_fbar
fbar(flash_stf)[,ac(2009:2011)]
fbar(flasher_stf)[,ac(2009:2011)]
```

Any differences?

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

As above, all metrics apart from total catch and mean catch weight are the same.

### SSB target

SSB measures the mass of the mature stock at the time of spawning.
With **FLash** the timing of the SSB target depends on the *harvest.spwn* slot in the *FLStock* object.
Both **FLash** and **FLasher** attempt to find the level of fishing pressure (F or effort) that will hit the desired target.
If spawning occurs during or after the fishing period, the SSB target can be hit in that year.
However, if spawning occurs before fishing starts then changing the fishing pressure will not affect the SSB in that year and so it is not possible to hit the target in that year.
In this case the target is hit in the following year.

#### Example when spawning occurs after the fishing period

In this example, the *harvest.spwn* and *m.spwn* slots have a value of 0.5, i.e. half of years natural and fishing mortality happens before spawning takes place.

```{r }
ple4_stf@harvest.spwn[] <- 0.5
ple4_stf@m.spwn[] <- 0.5
```

We run a three year projection, trying to hit an SSB target in each year.

With **FLash**:

```{r }
target_ssb <- c(180000, 170000, 160000)
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "ssb",
			  val = target_ssb)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "ssb",
                        order = 1:3, value = target_ssb)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit in their projection years?

```{r }
target_ssb
ssb(flash_stf)[,ac(2009:2011)]
ssb(flasher_stf)[,ac(2009:2011)]
```

Any differences?

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

All metrics apart from total catch and mean catch weight are the same.

#### Example when spawning occurs before the fishing period

If the spawning occurs before the fisbing period, then changing the fishing pressure will not affect the SSB in that year.
This means that we cannot hit the target by changing the fishing pressure in that year.

In this example, the *harvest.spwn* and *m.spwn* slots have a value of 0, i.e. spawning happens before any natural mortality or fishing takes place.

```{r }
ple4_stf@harvest.spwn[] <- 0
ple4_stf@m.spwn[] <- 0
```

First we run the **FLash** projection:

```{r }
target_ssb <- c(180000, 170000, 160000)
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "ssb",
			  val = target_ssb)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl,sr = list(model = model, params=params(ple4.sr)))
```

**FLash** reports an error ("Error:LUFactorisation...") but still returns an object.
The error is caused by trying to hit the SSB target in the 2012 which is outside the range of our object.

```{r }
flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "ssb",
                        order = 1:3, value = target_ssb)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

**Flasher** reports a warning about trying to calculate SRP in a timstep outside the range of your object.
This is also caused by trying to hit the SSB target in the 2012.
**FLasher** still returns an object.

Did we hit the targets?

```{r }
target_ssb
ssb(flash_stf)[,ac(2009:2011)]
ssb(flasher_stf)[,ac(2009:2011)]
```

Here, the first SSB target is hit in the second year of the forecast as it is not possible to hit it in the first year.
The SSB in the first forecast year (2009) is based on the exising F in the previous year (2008).
The second SSB target is hit in the final year of the projection.

Both **FLasher** and **FLash** try to hit the final SSB target in 2012 but are unable to as the objects only go to 2011.
There is a difference between **FLash** and **FLasher** in how they handle the attempt to hit a target beyond the range of the object.
This can be seen in the projected Fs

```{r }
fbar(flash_stf)[,ac(2009:2011)]
fbar(flasher_stf)[,ac(2009:2011)]
```

In both cases all metrics that are derived from fishing pressure (e.g. landings, discards, F etc) in the final year should be ignored and only the stock abundances considered.

We just compare the first two years of the projection:

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2010)
```

All metrics apart from total catch and mean catch weight are the same.

## Min and max targets

Both **FLash** and **FLasher** can place bounds on some metrics when attempting to hit targets.

### Maximum target

Here we project with a landings target but with a maximum limit on discards.
We still use a single iteration without stochasticity.

The same target and maximum limit is applied in all years.

```{r }
landings_target <- 30000
discards_max <- 20000
```

The **FLash** projection:

```{r }
flash_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
			  quantity = rep(c("landings", "discards"), 3),
			  val = rep(c(landings_target, NA), 3),
			  max = rep(c(NA, discards_max), 3))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results="hide", message=FALSE}
flasher_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
                        quant = rep(c("landings", "discards"), 3), order = 1:6,
                        value = rep(c(landings_target, NA), 3),
                        max = rep(c(NA, discards_max), 3))
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit and the limits respected?
The landings target is possible only in 2010 and 2011. In 2009 the discards limit has been reached and consequently restricts the landings.

```{r}
landings_target
discards_max
landings(flash_stf)[,ac(2009:2011)]
discards(flash_stf)[,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
discards(flasher_stf)[,ac(2009:2011)]
```

Are the **FLash** and **FLasher** objects the same?

```{r}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

All metrics apart from total catch and mean catch weight are the same.

### Minimum target

Here we set a landings target with a minimum SSB restriction.
To avoid the additional time shifting complications when spawning takes place before fishing, *harvest.spwn* and *m.spwn* will be set to 0.5.

```{r }
ple4_stf@harvest.spwn[] <- 0.5
ple4_stf@m.spwn[] <- 0.5
```

```{r }
landings_target <- 100000
ssb_min<- 150000
```

The **FLash** projection:

```{r }
flash_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
			  quantity = rep(c("landings", "ssb"), 3),
			  val = rep(c(landings_target, NA), 3),
			  min = rep(c(NA, ssb_min), 3))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results="hide", message=FALSE}
flasher_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
                        quant = rep(c("landings", "ssb"), 3), order = 1:6,
                        value = rep(c(landings_target, NA), 3),
                        min = rep(c(NA, ssb_min), 3),
                        fishery = NA, catch = NA, biol = 1)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

What happened?

```{r }
landings_target
ssb_min
landings(flash_stf)[,ac(2009:2011)]
ssb(flash_stf)[,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
ssb(flasher_stf)[,ac(2009:2011)]
```

Here the SSB limit has constrained the landings in 2010 and 2011.

Are the **FLash** and **FLasher** objects the same?

```{r}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

All metrics apart from total catch and mean catch weight, are the same.

## Relative targets

**FLash** and **FLasher** are able to set relative targets.
In this example we set the F to be relative to the previous year.

```{r}
relative_target <- 0.9
```

The **FLash** projection:

```{r}
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "f",
			  val = relative_target, rel.year = 2008:2010)
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results="hide"}
flasher_ctrl_target <- data.frame(year = 2009:2011,
                        relYear = 2008:2010,
                        quant = "f", order = 1:3,
                        value = relative_target)
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Is the F correctly relative?

```{r}
fbar(flash_stf)[,ac(2009:2011)] /
    fbar(flash_stf)[,ac(2008:2010)]
fbar(flasher_stf)[,ac(2009:2011)] /
    fbar(flasher_stf)[,ac(2008:2010)]
```

Are the **FLash** and **FLasher** objects the same?

```{r}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### Relative targets with limits

It is possible to mix relative targets and limits.
Here we increase landings by a relative amount each year, but set a maximum discards limit.

The **FLash** projection:

```{r}
discards_max <- 10000
relative_landings <- 0.9
flash_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
			  quantity = rep(c("landings", "discards"), 3),
			  val = rep(c(relative_landings, NA), 3),
			  max = rep(c(NA, discards_max), 3),
            rel.year = c(2008, NA, 2009, NA, 2010, NA))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results='hide'}
flasher_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
                        relYear = c(2008, NA, 2009, NA, 2010, NA),
                        quant = rep(c("landings", "discards"), 3),
                        value = rep(c(relative_landings, NA), 3),
                        max = rep(c(NA, discards_max), 3),
                        order = c(1:6))
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Relative targets have been hit, respecting the limits:

```{r}
discards(flash_stf)[,ac(2009:2011)]
landings(flash_stf)[,ac(2009:2011)] / landings(flash_stf)[,ac(2008:2010)]

discards(flasher_stf)[,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)] / landings(flasher_stf)[,ac(2008:2010)]
```

And the objects are the same (ignoring total catch and mean catch weights).

```{r}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### Relative targets with relative limits

In this example we attempt to change F by a relative amount but we also constrain this through the amount landings is allowed to change each year by adding relative min and max limits.
The relative F values are deliberately extreme to trigger the limits.


The **FLash** projection:

```{r}
max_relative_landings <- 1.15
min_relative_landings <- 0.85
relative_F <- c(0.5, 0.8, 1.5)

flash_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
                    quantity = rep(c("f", "landings"), 3),
                    val = c(relative_F[1], NA, relative_F[2], NA, relative_F[3], NA),
                    max = rep(c(NA, max_relative_landings), 3),
                    min = rep(c(NA, min_relative_landings), 3),
                    rel.year = rep(2008:2010, each=2))
flash_ctrl <- FLash:::fwdControl(flash_ctrl_target)
flash_stf <- FLash:::fwd(ple4_stf, flash_ctrl, ple4.sr)
```

The **FLasher** projection:

```{r, results='hide'}
flasher_ctrl_target <- data.frame(year = rep(2009:2011, each=2),
                        relYear = rep(2008:2010, each=2),
                        quant = rep(c("f", "landings"), 3),
                        value = c(relative_F[1], NA, relative_F[2], NA, relative_F[3], NA),
                        max = rep(c(NA, max_relative_landings), 3),
                        min = rep(c(NA, min_relative_landings), 3),
                        order = c(1:6))
flasher_ctrl <- FLasher:::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

What happened?
The relative F target was only hit in the second year of the projection.
The required changes in landings with the F target were higher than the limits imposed in the first and final year.

```{r, results='hide'}
fbar(flash_stf)[,ac(2009:2011)] / fbar(flash_stf)[,ac(2008:2010)]
landings(flash_stf)[,ac(2009:2011)] / landings(flash_stf)[,ac(2008:2010)]

fbar(flasher_stf)[,ac(2009:2011)] / fbar(flasher_stf)[,ac(2008:2010)]
landings(flasher_stf)[,ac(2009:2011)] / landings(flasher_stf)[,ac(2008:2010)]
```

The **FLash** and **FLasher** results are the same (ignoring total catch and mean catch weights).

```{r}
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```


## Projections with stochasticity

Here we run projections but this time with stochasticity through multiple iterations.

There are several methods of doing this:
    * Iterations in the *FLStock* object that represent variability in the stock and catch parameters;
    * Stochasticity in the stock-recruitment relationship through residuals;
    * Stochasticity in the stock-recruitment relationship through iterations in the parameters;
    * Stochasticity in the target values

These methods can be combined.

First we expand the objects to have multiple iterations and then set up a projection using *stf()*.
```{r }
niters <- 100
ple4p <- propagate(ple4, niters)
ple4p_stf <- stf(ple4p, 3)
```

### Iterations in the *FLStock*

In this example we only add variability to the stock object to be projected.
The stock recruitment relationship is still deterministic, as are the target values.

We add stochasticity to the initial stock abundances and meand landings and discard weights. 

```{r }
stock.n(ple4_stf) <- rnorm(niters, mean=stock.n(ple4_stf), sd=100)
stock.wt(ple4_stf) <- rnorm(niters, mean=stock.wt(ple4_stf), sd=0.01)
landings.wt(ple4_stf) <- rnorm(niters, mean=landings.wt(ple4_stf), sd=0.01)
discards.n(ple4_stf) <- rnorm(niters, mean=discards.wt(ple4_stf), sd=0.01)
```

We project for 3 years with a simple landings target.

```{r}
landings_target <- seq(from=48000, to=45000, length=3)

flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "landings",
			  val = landings_target)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)))

flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "landings", order = 1:3,
                        value = landings_target)
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target)
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
landings_target
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```
And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### Adding iterations in the stock-recruitment relationship through multiplicative residuals

Here we include stochasticity through residuals in the stock-recruitment relationship, as well through the variability in the *FLStock* object.


We make an *FLQuant* of residuals for the projection years by by sampling from the fitted stock-recruitment relationship.

```{r }
residuals <- FLQuant(NA, dimnames=list(year=2009:2011, iter=1:niters))
residuals[] <- sample(c(exp(residuals(ple4.sr))), prod(dim(residuals)), replace=TRUE)
```

We run the same projections as above (with a landings target) but this time also include the residuals.
To project with **FLash** and **FLasher** we pass in the residuals that contains the years of the projection we are performing.

```{r }
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)), sr.residuals=residuals, sr.residuals.mult=TRUE)
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)), sr.residuals=residuals, sr.residuals.mult=TRUE)
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
landings_target
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```
And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

Here we take a closer look at the predicted recruitment and check that it has been calculated correctly (taking the recruitment in the final year):

```{r }
# Get the predicted deterministic recruitment using SSB in 2010
rec_det_flash <- predict(ple4.sr, ssb=ssb(flash_stf)[,ac(2010)])
rec_det_flasher <- predict(ple4.sr, ssb=ssb(flasher_stf)[,ac(2010)])
# Apply the residuals
rec_det_flash * residuals[,ac(2011)]
rec_det_flasher * residuals[,ac(2011)]
# Compare the predicted recruiment from FLash and FLasher
rec(flash_stf)[,ac(2011)]
rec(flasher_stf)[,ac(2011)]
```

### Adding iterations in the stock-recruitment relationship through the parameters

Here we use iterations in the SRR parameters to introduce stochasticity in the projections.
First we put some random noise on the SRR parameters:

```{r }
sr_params <- params(ple4.sr)
sr_params <- propagate(sr_params, niters)
sr_params[] <- rnorm(niters, mean=params(ple4.sr), sd=10)
```

We run the same simple landings based projection:

```{r }
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=sr_params))
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=sr_params))
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
landings_target
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```
And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```
### Adding iterations in the stock-recruitment relationship through the parameters and residuals

Here we combine the previous two examples so we have stochasticity in the *FLStock* parameters, SRR parameters and SRR residuals.

```{r }
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=sr_params), sr.residuals=residuals, sr.residuals.mult=TRUE)
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=sr_params), sr.residuals=residuals, sr.residuals.mult=TRUE)
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
landings_target
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```
And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

###  Including variability in the target values

Here we ignore stochasticity in the SRR but include variability in the target values.
We use the same landings target example but this time with stochasticity in the landings targets.

```{r}
# Set up the landings targets
landings_target <- seq(from=48000, to=45000, length=3)
landings_target_stoch <- rnorm(niters*length(landings_target), mean=landings_target, sd=100)

# With FLash this is a bit of pain as we have to hand crank the target array
flash_ctrl_target <- data.frame(year = 2009:2011,
			  quantity = "landings",
			  val = landings_target)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
new_trgtArray <- array(NA, dim=c(3,3,niters), dimnames=list(1:3, c("min","val","max"), iter=1:niters))
new_trgtArray[,"val",] <- landings_target_stoch
flash_ctrl@trgtArray <- new_trgtArray
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)))

# With FLasher it is slightly easier as we can specify the size of the iteration array
flasher_ctrl_target <- data.frame(year = 2009:2011,
                        quant = "landings", order = 1:3,
                        value = landings_target)
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target, iters=niters)
# Add the stochasticity to the target values
flasher_ctrl@iters[,"value",] <- landings_target_stoch
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)))
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
FLQuant(landings_target_stoch, dimnames=list(year=2009:2011, iter=1:niters))
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```

And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

### All sources of stochasticity!

Stock parameter variability + SRR parameter variability + SRR residuals + target value variability.

Everything at the same time!

```{r }
flash_stf <- FLash::fwd(ple4p_stf, flash_ctrl, sr = list(model = model, params=sr_params), sr.residuals=residuals, sr.residuals.mult=TRUE)
flasher_stf <- fwder(ple4p_stf, flasher_ctrl, sr = list(model = model, params=sr_params), sr.residuals=residuals, sr.residuals.mult=TRUE)
```

Have the targets been hit in the projection years 2009 to 2011?

```{r }
FLQuant(landings_target_stoch, dimnames=list(year=2009:2011, iter=1:niters))
landings(flash_stf)  [,ac(2009:2011)]
landings(flasher_stf)[,ac(2009:2011)]
```

And the ouput is the same (apart from the total catch and mean catch weights).

```{r }
flash_flasher_comp(flash_stf, flasher_stf, 2009:2011)
```

## The 'Massive Cake' example

In this example we combine many of the above features into a longer term projection.
The projection tries to hit a fixed F target (i.e. FMSY) but the landings are not allowed to change by more than 15% each year.

Stochasticity is included through multiple iterations in the stock object, variability in the SRR parameters, SRR residuals and iterations in the F target values.

The SRR is a Ricker (a Beverton-Holt was used in the previous projections).

We start the entire process from scratch.


Generate the first we propagate the original stock object to have multiple iterations, add noise to those iterations, then fit a separate SRR for each iteration (takes time):

```{r }
niters <- 250
ple4p <- propagate(ple4, niters)
stock.n(ple4p) <- rnorm(niters, mean=stock.n(ple4), sd=100)
stock.wt(ple4p) <- rnorm(niters, mean=stock.wt(ple4), sd=0.01)
landings.wt(ple4p) <- rnorm(niters, mean=landings.wt(ple4), sd=0.01)
discards.wt(ple4p) <- rnorm(niters, mean=discards.wt(ple4), sd=0.01)
# Fit the SRR - have a cup of tea while it does it...
model <- "ricker"
ple4.sr <- fmle(as.FLSR(ple4p, model=model), control=list(trace=0))
```

Set up the stock object for the projections and the residuals from the SRR:

```{r }
nyears <- 22
proj_years <- 2008 + (1:nyears)
ple4p_mtf <- stf(ple4p, nyears)
residuals <- FLQuant(NA, dimnames=list(year=proj_years, iter=1:niters))
# Need to keep iters distinct
for (i in 1:niters){
    iter(residuals,i)[] <- sample(c(exp(iter(residuals(ple4.sr),i))), prod(dim(iter(residuals,i))), replace=TRUE)
}
```

Set up the control objects. Ideally FMSY would be calculated using FLBRP. To keep things simple here we just make up some values.

```{r }
fmsy <- rlnorm(niters, mean=log(0.2), sd=0.1)
max_relative_landings <- 1.15
min_relative_landings <- 0.85
rel_years <- rep(proj_years-1,each=2)
rel_years[c(TRUE,FALSE)] <- NA

# FLash
flash_ctrl_target <- data.frame(year = rep(proj_years, each=2),
                    quantity = rep(c("f", "landings"), nyears),
                    val = rep(c(fmsy[1], NA), nyears),
                    max = rep(c(NA, max_relative_landings), nyears),
                    min = rep(c(NA, min_relative_landings), nyears),
                    rel.year = rel_years)
flash_ctrl <- FLash::fwdControl(flash_ctrl_target)
# This is hard work!
new_trgtArray <- array(NA, dim=c(nyears*2,3,niters), dimnames=list(1:(nyears*2), c("min","val","max"), iter=1:niters))
new_trgtArray[c(TRUE,FALSE),"val",] <- rep(fmsy,each=nyears)
new_trgtArray[c(FALSE,TRUE),"min",] <- min_relative_landings
new_trgtArray[c(FALSE,TRUE),"max",] <- max_relative_landings
flash_ctrl@trgtArray <- new_trgtArray

# FLasher
flasher_ctrl_target <- data.frame(year = rep(proj_years, each=2),
                    quant = rep(c("f", "landings"), nyears),
                    value = rep(c(fmsy[1], NA), nyears),
                    max = rep(c(NA, max_relative_landings), nyears),
                    min = rep(c(NA, min_relative_landings), nyears),
                    relYear = rel_years,
                    order = 1:(nyears*2))
flasher_ctrl <- FLasher::fwdControl(flasher_ctrl_target, iters=niters)

# Need to reorder here - should be done in constructor
# Reorder ctrl@target by order
ctrl_order <- order(flasher_ctrl@target$order)
flasher_ctrl@target <- flasher_ctrl@target[ctrl_order,]
flasher_ctrl@iters <- flasher_ctrl@iters[ctrl_order,,,drop=FALSE]

flasher_ctrl@iters[c(TRUE,FALSE),"value",] <- rep(fmsy,each=nyears)
flasher_ctrl@iters[c(FALSE,TRUE),"min",] <- min_relative_landings
flasher_ctrl@iters[c(FALSE,TRUE),"max",] <- max_relative_landings
```

We run the projections and time them (for interest):

```{r }
flash_time <- system.time(flash_mtf <- FLash::fwd(ple4p_mtf, flash_ctrl, sr = list(model = model, params=params(ple4.sr)), sr.residuals=residuals, sr.residuals.mult=TRUE))
flasher_time <- system.time(flasher_mtf <- fwder(ple4p_mtf, flasher_ctrl, sr = list(model = model, params=params(ple4.sr)), sr.residuals=residuals, sr.residuals.mult=TRUE))
```

FLash is probably faster:

```{r }
print(flash_time)
print(flasher_time)
```

Was the F target hit? Eventually, but the landings are constrained in the early years of the projection.

```{r }
FLQuant(rep(fmsy, each=nyears), dimnames=list(year=proj_years, iter=1:niters))
fbar(flash_mtf)[,ac(proj_years)]
fbar(flasher_mtf)[,ac(proj_years)]

landings(flash_mtf)[,ac(proj_years)] / landings(flash_mtf)[,ac(proj_years-1)]
landings(flasher_mtf)[,ac(proj_years)] / landings(flasher_mtf)[,ac(proj_years-1)]
```

Are the **FLash** and **FLasher** results the same?

```{r }
flash_flasher_comp(flash_mtf, flasher_mtf, proj_years)
```

Yes

## What happens when things go wrong?

A comparison of errors (F maxes out, targets not hit, etc.)





